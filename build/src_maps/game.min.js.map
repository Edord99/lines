{"version":3,"sources":["Sprite.js","UI.js","Button.js","Entity.js","Game.js","GameAnim.js","Manager.js","Scene.js","SceneManager.js","SpriteCollection.js","Stats.js","Text.js","TextButton.js","Texture.js","Toggle.js"],"names":["Sprite","[object Object]","x","y","w","h","animation","callback","this","position","Cool","Vector","size","debug","debugColor","collider","isActive","center","addAnimation","mouseOver","waitToGoOut","clickStarted","width","height","xy","copy","subtract","divide","GAME","ctx","lineWidth","beginPath","rect","temp","strokeStyle","stroke","isOnScreen","drawDebug","draw","update","displayFunc","other","next","nextCollider","add","velocity","nextSize","tap","onOver","onOut","onDown","onUp","onClick","func","UI","params","super","hidden","states","state","scenes","window","Button","over","out","down","up","Entity","origin","offset","Game","canvas","document","getElementById","lps","mixedColors","drawTime","performance","now","drawInterval","updateTime","updateInterval","clearBg","bounds","top","bottom","left","right","SceneManager","Scene","data","anims","useMouseEvents","events","includes","useKeyboardEvents","getContext","dpr","checkRetina","devicePixelRatio","scale","style","zoom","lineColor","stats","Stats","create","miterLimit","files","console","time","assetsLoaded","numFiles","Object","keys","length","f","file","fetch","then","response","ok","url","text","json","Error","entries","key","loadJSON","src","csv","CSVToArray","splice","i","itemName","catch","error","loader","setInterval","loaded","k","timeEnd","clearInterval","start","GameAnim","loadData","requestAnimFrame","startMouseEvents","startKeyboardEvents","sizeCanvas","addEventListener","clearRect","dir","value","dragOffset","dragStarted","ev","preventDefault","mouseClicked","offsetX","offsetY","mouseDown","which","shiftKey","startDrag","mouseUp","mouseMoved","drag","keyDown","target","tagName","keyUp","LinesAnimation","loop","randomFrames","isPlaying","currentFrame","currentState","end","currentFrameCounter","intervalRatio","Math","floor","prevFrame","frame","randomInt","onUpdate","frame4","onPlayedOnce","undefined","onPlayedState","label","_state","Manager","list","_class","_current","current","currentName","displaySprites","SpriteCollection","updateSprites","uiSprites","sprite","type","types","index","indexOf","all","display","item","addToDisplay","addUI","sprites","push","count","startTime","stat","round","fillStyle","fillRect","font","fillText","Text","msg","wrap","letters","letterIndexString","lead","track","breaks","setBreaks","hover","indexString","createNewState","breakOnNextSpace","prevBreak","match","countForward","countBackward","_x","_y","len","letter","TextButton","setCollider","setMsg","setPosition","Texture","locations","loc","randomIndex","endFrame","Toggle","toggled","toggle"],"mappings":"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","file":"../game.min.js","sourcesContent":["/*\n\tbase class for all game objects\n\tusually has an animation\n\tphysics and scaling removed in recent version\n*/\n\nclass Sprite {\n\tconstructor(x, y, w, h, animation, callback) {\n\t\tthis.position = new Cool.Vector(x, y);\n\t\tthis.size = new Cool.Vector(w, h);\n\t\tthis.debug = false;\n\t\tthis.debugColor = \"#00ffbb\";\n\t\tthis.collider = {\n\t\t\tposition: new Cool.Vector(0, 0),\n\t\t\tsize: new Cool.Vector(w, h)\n\t\t};\n\t\tthis.isActive = true;  // need a better name for this - disabled or something ... \n\t\tthis.center = false;\n\n\t\tif (animation) this.addAnimation(animation, callback);\n\n\t\tthis.mouseOver = false;\n\t\tthis.waitToGoOut = false;\n\t\tthis.clickStarted = false;\n\t\t// onOver, onOut, onUp, onDown, onClick\n\t}\n\n\tget width() {\n\t\treturn this.size.x;\n\t}\n\n\tget height() {\n\t\treturn this.size.y;\n\t}\n\n\tget xy() {\n\t\treturn this.center ? this.position.copy().subtract(this.size.copy().divide(2)) : this.position;\n\t}\n\n\tget x() {\n\t\treturn this.xy.x;\n\t}\n\n\tget y() {\n\t\treturn this.xy.y;\n\t}\n\n\taddAnimation(animation, callback) {\n\t\tthis.animation = animation;\n\t\tthis.size.x = this.collider.size.x = this.animation.width;\n\t\tthis.size.y = this.collider.size.y = this.animation.height;\n\t}\n\n\tsetCollider(x, y, w, h) {\n\t\tthis.collider.position.x = x;\n\t\tthis.collider.position.y = y;\n\t\tthis.collider.size.x = w;\n\t\tthis.collider.size.y = h;\n\t}\n\n\tdrawDebug() {\n\t\tGAME.ctx.lineWidth = 1;\n\t\tGAME.ctx.beginPath();\n\t\tGAME.ctx.rect(\n\t\t\tthis.x + this.collider.position.x,\n\t\t\tthis.y + this.collider.position.y,\n\t\t\tthis.collider.size.x, \n\t\t\tthis.collider.size.y\n\t\t);\n\t\tconst temp = GAME.ctx.strokeStyle;\n\t\tGAME.ctx.strokeStyle = this.debugColor;\n\t\tGAME.ctx.stroke();\n\t\tGAME.ctx.strokeStyle = temp;\n\t}\n\n\tdisplay() {\n\t\tif (this.isActive && this.isOnScreen()) {\n\t\t\tif (this.debug) this.drawDebug();\n\t\t\tif (this.animation) {\n\t\t\t\tthis.animation.draw(this.x, this.y);\n\t\t\t\tthis.animation.update();\n\t\t\t}\n\t\t}\n\t\tif (this.displayFunc) this.displayFunc();\n\t}\n\n\tisOnScreen() {\n\t\tif (this.x + this.width > 0 && \n\t\t\tthis.y + this.height > 0 &&\n\t\t\tthis.x < GAME.width &&\n\t\t\tthis.y < GAME.height)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t} \n\n\ttap(x, y) {\n\t\tif (x > this.x + this.collider.position.x &&\n\t\t\tx < this.x + this.collider.position.x + this.collider.size.x && \n\t\t\ty > this.y + this.collider.position.y && \n\t\t\ty < this.y + this.collider.position.y + this.collider.size.y) {\n\t\t\treturn true;\n\t\t} else \n\t\t\treturn false;\n\t}\n\n\tcollide(other, callback) {\n\t\tif (this.isActive && other.isActive) {\n\t\t\tif (this.x + this.collider.position.x < other.x + other.collider.position.x + other.collider.size.x &&\n\t\t\t\tthis.x + this.collider.position.x + this.collider.size.x > other.x + other.collider.position.x &&\n\t\t\t\tthis.y + this.collider.position.y < other.y + other.collider.position.y + other.collider.size.y &&\n\t\t\t\tthis.y + this.collider.position.y + this.collider.size.y > other.y + other.collider.position.y) {\n\t\t\t\tif (callback) callback(this);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\toutside(other) {\n\t\tvar next = this.position.copy();\n\t\tvar nextCollider = this.collider.position.copy();\n\t\tnext.add(nextCollider);\n\t\tnext.add(this.velocity);\n\t\tvar nextSize = this.collider.size.copy();\n\t\tif (next.x < other.position.x + other.collider.position.x ||\n\t\t\tnext.x + nextSize.x > other.position.x + other.collider.position.x + other.collider.size.x ||\n\t\t\tnext.y < other.position.y + other.collider.position.y ||\n\t\t\tnext.y + nextSize.y > other.position.y + other.collider.position.y + other.collider.size.y) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tover(x, y) {\n\t\t// console.log(x, y);\n\t\t// console.log(this.tap(x, y));\n\t\tif (this.isActive && this.tap(x,y) && !this.mouseOver && !this.waitToGoOut) {\n\t\t\tthis.mouseOver = true;\n\t\t\tif (this.onOver) this.onOver();\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tout(x, y) {\n\t\tif (this.isActive && !this.tap(x,y) && (this.mouseOver || this.waitToGoOut)) {\n\t\t\tthis.clickStarted = false;\n\t\t\tthis.waitToGoOut = false;\n\t\t\tthis.mouseOver = false;\n\t\t\tif (this.onOut) this.onOut();\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdown(x, y) {\n\t\tif (this.isActive && this.tap(x,y)) {\n\t\t\tthis.clickStarted = true;\n\t\t\tthis.waitToGoOut = true;\n\t\t\tif (this.onDown) this.onDown();\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tup(x, y) {\n\t\tif (this.isActive && this.tap(x,y) && this.clickStarted) {\n\t\t\tthis.mouseOver = false;\n\t\t\tif (this.onUp) this.onUp();\n\t\t\tif (this.onClick) this.onClick();\n\t\t\tif (this.func) func();\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tthis.clickStarted = false;\n\t}\n}\n","/*\n\tpositions sprites relative to game canvas dimensions\n*/\n\nclass UI extends Sprite {\n\tconstructor(params, debug) {\n\t\t/* xy orientation to game window */\n\t\tlet x = params.x;\n\t\tlet y = params.y;\n\t\tif (x % 1 != 0) x = GAME.width * x; /* decimal / percentage of window */\n\t\tif (x < 0) x = GAME.width + x; /* negative x offset from right side */\n\t\tif (y % 1 != 0) y = GAME.height * y; /* decimal / percentage of window */\n\t\tif (y < 0) y = GAME.height + y; /* negative y offset from bottom */\n\t\t\n\t\tsuper(x, y);\n\t\tthis.debug = debug;\n\t\tthis.center = true;\n\n\t\tif (params.hidden) this.isActive = false; /* hidden prob in garden json ...  */\n\t\tif (params.animation) this.addAnimation(params.animation);\n\t\tif (params.states) {\n\t\t\tthis.animation.states = params.states;\n\t\t\tthis.animation.state = 'idle';\n\t\t}\n\n\t\tthis.scenes = params.scenes; // deprecate ? \n\t\t\n\t\tif (params.func) this.func = window[params.func]; \n\t\t/* shouldnt be attached to window - fine for now */\n\t}\n}\n","/*\n\tSprite -> UI -> Button\n*/\n\nclass Button extends UI {\n\tconstructor(params, debug) {\n\t\tsuper(params, debug);\n\n\t\tthis.mouseOver = false;\n\t\tthis.waitToGoOut = false;\n\t\tthis.clickStarted = false;\n\n\t\tif (params.onOver) this.onOver = params.onOver;\n\t\tif (params.onOut) this.onOut = params.onOut;\n\t\tif (params.onDown) this.onDown = params.onDown;\n\t\tif (params.onClick) this.onClick = params.onClick;\n\t}\n\n\tover(x, y) {\n\t\tconst over = super.over(x, y);\n\t\tif (over) this.animation.state = 'over';\n\t\treturn over;\n\t}\n\n\tout(x, y) {\n\t\tconst out = super.out(x, y);\n\t\tif (out) this.animation.state = 'idle';\n\t\treturn out;\n\t}\n\n\tdown(x, y) {\n\t\tconst down = super.down(x, y);\n\t\tif (down)  this.animation.state = 'active';\n\t\treturn down;\n\t}\n\n\tup(x, y) {\n\t\tconst up = super.up(x, y);\n\t\tif (up) this.animation.state = 'idle';\n\t\treturn up;\n\t}\n}","/*\n\tSprite -> Entity\n\tEntity is basically anything that appears on the map\n\tneeds to be updated by offset generated in game map\n\n\tsprite position is draw position - origin + offset\n\torigin is really map position\n*/\n\nclass Entity extends Sprite {\n\tconstructor(params, debug) {\n\t\tsuper(params.x, params.y);\n\t\tthis.debug = debug;\n\t\tthis.origin = new Cool.Vector(params.x, params.y);\n\t\t// this.origin = { x: params.x, y: params.y };\n\n\t\tthis.center = params.center || true;\n\t}\n\n\tupdate(offset) {\n\t\t/* simpler than vectors */\n\t\tthis.position.x = this.origin.x + offset.x;\n\t\tthis.position.y = this.origin.y + offset.y;\n\t}\n\n\tsetPosition(x, y) {\n\t\tthis.origin.x = x;\n\t\tthis.origin.y = y;\n\t}\n}","/*\n\tthis is really more like the game loader, renderer, doesn't handle game logic\n\tloads files\n\trenders and updates\n\tmanage canvas\n\tmanages scenes\n\tstart function called when load ends ... calls start, update, draw\n\tparams.events - mouse, keyboard, mouse+keyboard\n\n\tuser defined functions:\n\tstart - create anything using loaded animations\n\tdraw - draw sprites, anything not in scenes\n\tupdate - update user input only\n\n\tsizeCanvas - handle canvas resize\n\n\tkeyDown(key)\n\tkeyUp(key)\n\n\tmouseMoved(x, y, which)\n\tmouseDown(x, y, which)\n\tmouseUp(x, y, which)\n*/\n\nclass Game {\n\tconstructor(params) {\n\t\twindow.GAME = this; // for references in sub classes\n\n\t\tthis.canvas = document.getElementById(params.canvas || \"lines\");\n\n\t\tthis.width = params.width;\n\t\tthis.height = params.height;\n\t\tthis.lps = params.lps;\n\t\tthis.mixedColors = params.mixedColors || false; /* param? */\n\t\tthis.debug = params.debug || false;\n\n\t\tthis.drawTime = performance.now();\n\t\tthis.drawInterval = 1000 / params.lps;\n\n\t\tthis.updateTime = this.drawTime;\n\t\tthis.updateInterval = 1000 / 60; // 60 fps\n\n\t\tthis.clearBg = true;\n\t\tthis.bounds = { top: 0, bottom: 0, left: 0, right: 0 };\n\n\t\tthis.scenes = new SceneManager(params.scenes, Scene);\n\n\t\tthis.data = {};\n\t\tthis.anims = {};\n\n\t\tthis.useMouseEvents = params.events ? params.events.includes('mouse') : true;\n\t\tthis.useKeyboardEvents = params.events ? params.events.includes('keyboard') : true;\n\n\n\t\tif (this.canvas.getContext) {\n\t\t\tthis.ctx = this.canvas.getContext('2d');\n\t\t\tthis.dpr = params.checkRetina ? window.devicePixelRatio || 1 : 1;\n\n\t\t\tthis.canvas.width = this.width * this.dpr;\n\t\t\tthis.canvas.height = this.height * this.dpr;\n\t\t\tthis.ctx.scale(this.dpr, this.dpr);\n\t\t\tthis.canvas.style.zoom = 1 / this.dpr;\n\n\t\t\tif (params.lineColor) this.ctx.strokeStyle = params.lineColor;\n\t\t\tif (params.scale) this.ctx.scale(params.scale, params.scale);\n\n\t\t\tif (params.stats) {\n\t\t\t\tthis.stats = new Stats(this.ctx, params.width);\n\t\t\t\tthis.stats.create('FPS', this.updateTime);\n\t\t\t\tthis.stats.create('draw', this.drawTime);\n\t\t\t}\n\n\t\t\tthis.ctx.miterLimit = 1; // do this last\n\t\t}\n\t}\n\n\tload(files, callback) {\n\t\tif (this.debug) console.time('load data');\n\t\tthis.assetsLoaded = {};\n\t\tconst numFiles = Object.keys(files).length;\n\t\tfor (const f in files) {\n\t\t\tconst file = files[f];\n\t\t\tfetch(file)\n\t\t\t\t.then(response => {\n\t\t\t\t\tif (response.ok) return response.url.includes('csv') ? response.text() : response.json();\n\t\t\t\t\tthrow new Error('Network response was not ok.');\n\t\t\t\t})\n\t\t\t\t.then(data => {\n\t\t\t\t\tthis.data[f] = {};\n\t\t\t\t\tthis.anims[f] = {};\n\t\t\t\t\tthis.assetsLoaded[f] = {};\n\t\t\t\t\tif (typeof data == 'object') {\n\t\t\t\t\t\tthis.data[f].entries = data;\n\t\t\t\t\t\tfor (const key in data) {\n\t\t\t\t\t\t\tthis.assetsLoaded[f][key] = false;\n\t\t\t\t\t\t\tthis.loadJSON(f, key, data[key].src);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// csv item names have to match drawing names\n\t\t\t\t\t\tconst csv = CSVToArray(data, ',').splice(1);\n\t\t\t\t\t\tthis.data[f].entries = csv;\n\t\t\t\t\t\tfor (let i = 0; i < csv.length; i++) {\n\t\t\t\t\t\t\tconst itemName = csv[i][0];\n\t\t\t\t\t\t\tthis.assetsLoaded[f][itemName] = false;\n\t\t\t\t\t\t\tthis.loadJSON(f, itemName, `drawings/${f}/${itemName}.json`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(error => {\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t\tthis.assetsLoaded[f] = true;\n\t\t\t\t});\n\t\t}\n\n\t\tconst loader = setInterval(() => {\n\t\t\tlet loaded = Object.keys(this.assetsLoaded).length == numFiles;\n\t\t\tfor (const f in this.assetsLoaded) {\n\t\t\t\tfor (const k in this.assetsLoaded[f]) {\n\t\t\t\t\tif (!this.assetsLoaded[f][k]) loaded = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (loaded) {\n\t\t\t\tif (this.debug) console.timeEnd('load data');\n\t\t\t\tclearInterval(loader);\n\t\t\t\t// when will this ever not be game start?\n\t\t\t\t// if (callback) callback();\n\t\t\t\tthis.start();\n\t\t\t}\n\t\t}, 1000 / 60);\n\t}\n\n\tloadJSON(file, key, src) {\n\t\tfetch(src)\n\t\t\t.then(response => { return response.json(); })\n\t\t\t.then(json => {\n\t\t\t\tthis.anims[file][key] = new GameAnim();\n\t\t\t\tthis.anims[file][key].loadData(json, () => {\n\t\t\t\t\tthis.assetsLoaded[file][key] = true;\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\tstart() {\n\t\tif (typeof start === \"function\") start(); // should be this method?\n\t\tif (typeof update === \"function\") requestAnimFrame(() => { this.update() });\n\t\tif (this.useMouseEvents) this.startMouseEvents();\n\t\tif (this.useKeyboardEvents) this.startKeyboardEvents();\n\t\tif (typeof sizeCanvas === \"function\") window.addEventListener('resize', sizeCanvas, false);\n\t}\n\n\tdraw(time) {\n\t\tif (this.clearBg) this.ctx.clearRect(0, 0, this.width * this.dpr, this.height * this.dpr);\n\n\t\t// add draw scenes ? \n\n\t\tdraw(); // draw defined in each this js file, or not ... \n\t\tif (this.stats) {\n\t\t\tthis.stats.update('draw', time);\n\t\t\tthis.stats.draw();\n\t\t}\n\t\tthis.drawTime = time - ((time - this.drawTime) % this.drawInterval);\n\t}\n\n\tupdate() {\n\t\trequestAnimFrame(() => { this.update(); });  // this context\n\n\t\tconst time = performance.now();\n\t\tif (time > this.updateTime + this.updateInterval) {\n\t\t\tupdate(); // update defined in each game js file\n\t\t\tthis.updateTime = time - ((time - this.updateTime) % this.updateInterval); // adjust for fps interval being off\n\t\t\tif (this.stats) this.stats.update('FPS', time);\n\t\t\t\n\t\t}\n\t\tif (time > this.drawTime + this.drawInterval) this.draw(time);\n\t}\n\n\tsetBounds(dir, value) {\n\t\tthis.bounds[dir] = value;\n\t}\n\n\tstartMouseEvents() {\n\t\tlet dragStarted = false;\n\t\tlet dragOffset;\n\n\t\tthis.canvas.addEventListener('click', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tif (typeof mouseClicked === \"function\") \n\t\t\t\tmouseClicked(ev.offsetX, ev.offsetY);\n\t\t}, false);\n\n\t\tthis.canvas.addEventListener('mousedown', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tif (typeof mouseDown === \"function\") \n\t\t\t\tmouseDown(ev.offsetX, ev.offsetY, ev.which, ev.shiftKey);\n\t\t\tif (typeof startDrag === \"function\") {\n\t\t\t\tdragOffset = startDrag(ev.offsetX, ev.offsetY);\n\t\t\t\tif (dragOffset) dragStarted = true;\n\t\t\t}\n\t\t}, false);\n\n\t\tthis.canvas.addEventListener('mouseup', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tif (typeof mouseUp === \"function\") \n\t\t\t\tmouseUp(ev.offsetX, ev.offsetY, ev.which);\n\t\t\tif (dragStarted) dragStarted = false;\n\t\t}, false);\n\n\t\tthis.canvas.addEventListener('mousemove', function(ev) {\n\t\t\tif (typeof mouseMoved === \"function\") \n\t\t\t\tmouseMoved(ev.offsetX, ev.offsetY, ev.which);\n\t\t\tif (dragStarted) \n\t\t\t\tdrag(ev.offsetX, ev.offsetY, dragOffset);\n\t\t}, false);\n\t}\n\n\tstartKeyboardEvents() {\n\t\tdocument.addEventListener('keydown', function(ev) {\n\t\t\tif (typeof keyDown === \"function\" && ev.target.tagName != \"INPUT\") \n\t\t\t\tkeyDown(Cool.keys[ev.which]);\n\t\t});\n\n\t\tdocument.addEventListener('keyup', function(ev) {\n\t\t\tif (typeof keyUp === \"function\" && ev.target.tagName != \"INPUT\") \n\t\t\t\tkeyUp(Cool.keys[ev.which]);\n\t\t});\n\t}\n}","class GameAnim extends LinesAnimation {\n\tconstructor(debug) {\n\t\tsuper(GAME.ctx, GAME.lps, GAME.mixedColors);\n\t\tthis.debug = debug;\n\t\tthis.loop = true;\n\t\tthis.randomFrames = false; /* play random frames */\n\t}\n\n\tupdate() { /* too many things to stick in onPlayedState etc */\n\t\tif (this.isPlaying) {\n\t\t\tif (this.currentFrame <= this.currentState.end) {\n\t\t\t\tthis.currentFrameCounter += this.intervalRatio;\n\t\t\t\tif (this.randomFrames && this.currentFrame != Math.floor(this.currentFrameCounter)) {\n\t\t\t\t\tconst prevFrame = this.currentFrame;\n\t\t\t\t\twhile (prevFrame == this.currentFrame) {\n\t\t\t\t\t\tthis.frame = Cool.randomInt(this.currentState.start, this.currentState.end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.currentFrame = Math.floor(this.currentFrameCounter);\n\t\t\t\tif (this.onUpdate) this.onUpdate();\n\t\t\t}\n\t\t}\n\n\t\tif (this.frame4 >= this.currentState.end + 1) { /* not DRY fuck me */\n\t\t\tif (this.loop) this.frame = this.currentState.start;\n\t\t\telse this.frame = this.currentState.end;\n\t\t\tif (this.onPlayedOnce) {\n\t\t\t\tthis.onPlayedOnce();\n\t\t\t\tthis.onPlayedOnce = undefined;\n\t\t\t}\n\t\t\tif (this.onPlayedState) this.onPlayedState();\n\t\t}\n\t}\n\n\tcreateNewState(label, start, end) {\n\t\tif (!this.states[label]) {\n\t\t\tthis.states[label] = {\n\t\t\t\tstart: start,\n\t\t\t\tend: end\n\t\t\t}\n\t\t}\n\t\tthis.state = label; /* ? */\n\t}\n\n\tset state(state) {\n\t\tif (this._state != state && this.states[state]) {\n\t\t\tthis._state = state;\n\t\t\tif (this.currentState) this.frame = this.currentState.start;\n\t\t\tif (!this.isPlaying && state != 'default') this.isPlaying = true; \n\t\t}\n\t}\n\n\tget state() {\n\t\treturn this._state;\n\t}\n\n\tplayOnce(callback) {\n\t\tif (!this.isPlaying) this.isPlaying = true;\n\t\tthis.frame = this.currentState.start;\n\t\tthis.onPlayedOnce = callback;\n\t}\n\n\tstop() {\n\t\tthis.isPlaying = false;\n\t}\n\n\tstart() {\n\t\tthis.isPlaying = true;\n\t}\n}","/*\n\tused for scenes: gme.scenes, gme.scenes.current etc\n\tcould also be implemented for animation states, other things with states\n\tbasically allows you to set with a string and get an object\n*/\n\nclass Manager {\n\tconstructor(list, _class) {\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tthis[list[i]] = new _class();\n\t\t}\n\t\tthis._current = list[0];\n\t}\n\n\tset current(label) {\n\t\tthis._current = label;\n\t}\n\n\tget current() {\n\t\treturn this[this._current];\n\t}\n\n\tget currentName() {\n\t\treturn this._current;\n\t}\n\n}","class Scene {\n\tconstructor() {\n\t\tthis.displaySprites = new SpriteCollection();\n\t\tthis.updateSprites = new SpriteCollection();\n\t\tthis.uiSprites = new SpriteCollection();\n\t}\n\n\tadd(sprite) {\n\t\tthis.displaySprites.add(sprite);\n\t\tthis.updateSprites.add(sprite);\n\t\tthis.uiSprites.add(sprite);\n\t}\n\n\tremove(sprite, type) {\n\t\tconst types = type ? [type] : ['display', 'update', 'ui'];\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tconst index = this[`${types[i]}Sprites`].indexOf(sprite);\n\t\t\tif (index >= 0) this[`${types[i]}Sprites`].splice(index, 1);\n\t\t}\n\t}\n\n\taddSprite(sprite) {\n\t\tthis.displaySprites.add(sprite);\n\t\tthis.updateSprites.add(sprite);\n\t}\n\n\taddUI(sprite) {\n\t\tthis.displaySprites.add(sprite);\n\t\tthis.uiSprites.add(sprite);\n\t}\n\n\taddToDisplay(sprite) {\n\t\tthis.displaySprites.add(sprite);\n\t}\n\n\taddToUpdate(sprite) {\n\t\tthis.updateSprites.add(sprite);\n\t}\n\n\taddToUI(sprite) {\n\t\tthis.uiSprites.add(sprite);\n\t}\n\n\tdisplay() {\n\t\tthis.displaySprites.all(sprite => { sprite.display() });\n\t}\n\n\tupdate() {\n\t\tthis.updateSprites.all(sprite => { sprite.update() });\n\t}\n\n\tmouseMoved(x, y) {\n\t\tthis.uiSprites.all(sprite => {\n\t\t\tsprite.over(x, y);\n\t\t\tsprite.out(x, y);\n\t\t});\n\t}\n\n\tmouseDown(x, y) {\n\t\tthis.uiSprites.all(sprite => { sprite.down(x, y); });\n\t}\n\n\tmouseUp(x, y) {\n\t\tthis.uiSprites.all(sprite => { sprite.up(x, y); });\n\t}\n}","class SceneManager extends Manager {\n\tadd(item, scenes, which) {\n\t\tif (typeof scenes == 'string') scenes = [scenes];\n\t\tfor (let i = 0; i < scenes.length; i++) {\n\t\t\tif (which == 'display') this[scenes[i]].addToDisplay(item);\n\t\t\telse if (which == 'ui') this[scenes[i]].addUI(item)\n\t\t\telse this[scenes[i]].add(item);\n\t\t}\n\t}\n}","/*\n\tused mostly by SceneManager to handle sprites for each scene\n\talso used by game asset managers like pack or map\n*/\n\nclass SpriteCollection {\n\tconstructor(sprites) {\n\t\tthis.sprites = sprites ? [...sprites] : [];\n\t}\n\n\tget length() {\n\t\treturn this.sprites.length;\n\t}\n\n\tsprite(index) {\n\t\treturn this.sprites[index];\n\t}\n\n\tremove(sprite) {\n\t\tthis.sprites.splice(this.sprites.indexOf(sprite), 1);\n\t}\n\n\tadd(sprite) {\n\t\tthis.sprites.push(sprite);\n\t}\n\n\t// loop \n\tall(callback) {\n\t\tfor (let i = 0; i < this.sprites.length; i++) {\n\t\t\tcallback(this.sprites[i], i);\n\t\t}\n\t}\n\n\tdisplay() {\n\t\tthis.all(sprite => { sprite.display(); });\n\t}\n}","/*\n\tstill figuring this out\n\trn just fps and draw/sec\n\twant to add millis\n*/\n\nclass Stats {\n\tconstructor(ctx, width) {\n\t\tthis.ctx = ctx;\n\t\tthis.width = width;\n\t\tthis.stats = {};\n\t}\n\n\tcreate(label, time) {\n\t\tthis.stats[label] = {\n\t\t\tcount: 0,\n\t\t\tstartTime: time,\n\t\t\tvalue: 0\n\t\t}\n\t}\n\n\tupdate(label, time) {\n\t\t// this.stats[label].push(time);\n\t\t// if (this.stats[label].length > 20) this.stats[label].shift();\n\t\n\t\tconst stat = this.stats[label];\n\t\t// if (label == 'draw') console.log(time, stat.startTime, stat.count);\n\t\tstat.count++;\n\t\tstat.value = Math.round(1000 / ((time - stat.startTime) / stat.count) * 100) / 100;\n\t}\n\n\tdraw() {\n\t\t// bg\n\t\tthis.ctx.fillStyle = 'rgba(0,0,0,0.75)';\n\t\tthis.ctx.fillRect(this.width - 65, 0, 60, 40);\n\n\t\tthis.ctx.font = 'lighter 11px sans-serif';\n\t\tthis.ctx.fillStyle = 'rgba(100,255,200)';\n\n\t\tlet x = this.width - 60;\n\t\tlet y = 15;\n\n\t\tfor (const label in this.stats) {\n\t\t\tconst stat = this.stats[label];\n\t\t\tthis.ctx.fillText(`${label} ${stat.value}`, x, y);\n\t\t\ty += 20;\n\t\t}\n\t}\n}","/*\n\tdraws text with lettering based on game text string\n\thandled by game so that each new text object doesn't have to add all the letters...\n\tmaybe just check first?\n*/\n\nclass Text {\n\tconstructor(x, y, msg, wrap, letters, letterIndexString) {\n\t\tthis.x = Math.round(x);\n\t\tthis.y = Math.round(y);\n\t\tthis.lead = 35; // leading is space between lines\n\t\tthis.track = 18; // tracking is space between letters\n\t\tthis.msg = msg;\n\t\tthis.wrap = wrap;\n\t\tthis.isActive = true;\n\t\tthis.letters = letters;\n\t\tthis.breaks = [];\n\t\tthis.setBreaks();\n\t\tthis.count = 0;\n\t\tthis.end = 0;\n\t\tthis.hover = false;\n\t\tthis.clickStarted = false;\n\n\t\tif (!letters.states[0]) {\n\t\t\tconst indexString = letterIndexString || \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,:?-+'&$;\\\"!\";\n\t\t\tfor (let i = 0; i < indexString.length; i++) {\n\t\t\t\tletters.createNewState(indexString[i], i, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetPosition(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tsetMsg(msg) {\n\t\tthis.msg = msg;\n\t\tthis.setBreaks();\n\t}\n\n\tsetBreaks() {\n\t\t/* \n\t\t\tset line breaks in message, \n\t\t\tbased on message length, new line & return keys\n\t\t\twaits for a space i guess?\n\t\t*/\n\n\t\tlet breakOnNextSpace = false; // wait for next space character\n\t\tlet offset = 0; // 0 matches first i % this.wrap, then moves to accomodate added characters for spaces\n\t\tlet prevBreak = false; // for space break followed by \\n\\r\n\t\tthis.breaks = [];\n\n\t\tfor (let i = 1; i < this.msg.length; i++) {\n\t\t\tprevBreak = false;\n\n\t\t\t// break on \\n\\r, check to make sure it didn't just break\n\t\t\tif (this.msg[i].match(/[\\n\\r]/g) && !prevBreak) {\n\t\t\t\tthis.breaks.push(i);\n\t\t\t\toffset = i % this.wrap;\n\t\t\t\tbreakOnNextSpace = false;\n\t\t\t}\n\n\t\t\telse if (i % this.wrap == offset && !breakOnNextSpace) {\n\t\t\t\tif (this.msg[i] == ' ') {\n\t\t\t\t\tthis.breaks.push(i);\n\t\t\t\t\tprevBreak = true;\n\t\t\t\t}\n\t\t\t\telse breakOnNextSpace = true;\n\t\t\t}\n\n\t\t\telse if (this.msg[i] == ' ' && breakOnNextSpace) {\n\t\t\t\tthis.breaks.push(i);\n\t\t\t\toffset = i % this.wrap;\n\t\t\t\tbreakOnNextSpace = false;\n\t\t\t\tprevBreak = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/* animate text backward and forward, maybe need to update - maybe add animate/update method? */\n\tdisplay(countForward, countBackward, _x, _y) {\n\t\tif (this.isActive) {\n\t\t\tconst len = countForward ? this.count : this.msg.length;\n\t\t\tconst index = countBackward ? this.end : 0;\n\t\t\tlet x = _x || this.x;\n\t\t\tlet y = _y || this.y;\n\t\t\t// y -= this.breaks.length * this.lead;\n\t\t\tfor (let i = index; i < len; i++) {\n\t\t\t\tvar letter = this.msg[i];\n\t\t\t\t// if (!letter.match(/[!a-zA-Z]/g)) console.log(letter);\n\t\t\t\tif (letter == ' ' || letter == '_') {\n\t\t\t\t\tx += this.track;\n\t\t\t\t} else if (letter == '\\n' || letter == '\\r') {\n\t\t\t\t\t// y += this.lead;\n\t\t\t\t\t// x = _x || this.x;\n\t\t\t\t} else {\n\t\t\t\t\tthis.letters.state = letter;\n\t\t\t\t\tthis.letters.draw(x, y);\n\t\t\t\t\tx += this.track;\n\t\t\t\t}\n\t\t\t\tif (this.breaks.indexOf(i) != -1) {\n\t\t\t\t\ty += this.lead;\n\t\t\t\t\tx = _x || this.x;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (this.count >= this.msg.length) this.end++;\n\t\t\telse this.count++;\n\t\t\tif (countBackward) {\n\t\t\t\tif (this.end >= this.msg.length) {\n\t\t\t\t\tthis.end = 0; /* reset */\n\t\t\t\t\tthis.count = 0;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.end >= 5) { // how long to wait after completed text // hardcoded?\n\t\t\t\t\tthis.end = 0;\n\t\t\t\t\tthis.count = 0;\n\t\t\t\t\treturn true; // ended\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n","/*\n\tSprite -> UI -> TextButton\n\ta ui sprite that has text to render instead of animation\n*/\n\nclass TextButton extends UI {\n\tconstructor(x, y, msg, wrap, letters) {\n\t\tsuper({x: x, y: y});\n\t\tthis.center = false;\n\t\tthis.text = new Text(this.position.x, this.position.y, msg, wrap, letters);\n\t\tthis.setCollider();\n\t}\n\n\tsetMsg(msg) {\n\t\tthis.text.setMsg(msg);\n\t\tthis.text.wrap = msg.length;\n\t\tthis.setCollider();\n\t}\n\n\tsetCollider() {\n\t\tthis.size.x = this.collider.size.x = (this.text.wrap < this.text.msg.length ? this.text.wrap : this.text.msg.length) * this.text.track;\n\t\tthis.size.y = this.collider.size.y = (this.text.breaks.length + 1) * this.text.letters.height;\n\t}\n\n\tdisplay() {\n\t\tsuper.display();\n\t\tif (this.isActive) this.text.display();\n\t}\n\n\tsetPosition(x, y) {\n\t\tthis.position.x = x;\n\t\tthis.position.y = y;\n\t\tthis.text.setPosition(x, y);\n\t}\n}","/*\n\tdraws frames from one animation in multuple places (locations)\t\n*/\n\nclass Texture {\n\tconstructor(params, debug) {\n\t\tthis.locations = params.locations || [];\n\t\tthis.frame = params.frame || 'index';\n\t\tthis.debug = debug;\n\t\tthis.center = params.center || false;\n\t\t\n\t\tthis.offset = new Cool.Vector(0, 0);\n\t\tif (params.animation) this.animation = params.animation;\n\t}\n\n\taddLocation(index, x, y) {\n\t\tthis.animation.createNewState(`f-${index}`, index, index);\n\t\tconst loc = new Cool.Vector(x, y);\n\t\tloc.i = index;\n\t\tthis.locations.push(loc);\n\t}\n\n\taddLocations(locations) {\n\t\tthis.locations.push(...locations);\n\t\tfor (let i = 0; i < this.locations.length; i++) {\n\t\t\tif (this.frame == 'index') {\n\t\t\t\tthis.locations[i].i = i;\n\t\t\t\tthis.animation.createNewState(`f-${i}`, i, i);\n\t\t\t}\n\t\t\telse if (this.frame == 'random') {\n\t\t\t\tthis.animation.randomFrames = true;\n\t\t\t}\n\t\t\telse if (this.frame == 'randomIndex') {\n\t\t\t\tlet randomIndex = Cool.randomInt(0, this.animation.endFrame);\n\t\t\t\tthis.locations[i].i = randomIndex;\n\t\t\t\tthis.animation.createNewState(`f-${randomIndex}`, randomIndex, randomIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\tdisplay() {\n\t\tfor (let i = 0; i < this.locations.length; i++) {\n\t\t\tlet x = this.locations[i].x + this.offset.x;\n\t\t\tlet y = this.locations[i].y + this.offset.y;\n\t\t\tif (this.center) {\n\t\t\t\tx -= this.animation.width / 2;\n\t\t\t\ty -= this.animation.height / 2;\n\t\t\t}\n\n\t\t\t//  figure out centering later, only draw textures on screen\n\t\t\tif (x + this.animation.width > 0 && x < GAME.width && \n\t\t\t\ty + this.animation.height > 0 && y < GAME.height) {\n\t\t\t\tif (this.locations[i].i) this.animation.state = `f-${this.locations[i].i}`;\n\t\t\t\tthis.animation.draw(x, y);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate(offset) {\n\t\tthis.offset.x = offset.x;\n\t\tthis.offset.y = offset.y;\n\t}\n}","/*\n\tSprite -> UI -> Button -> Toggle\n\tbutton with added toggled state\n*/\n\nclass Toggle extends Button {\n\tconstructor(params, debug) {\n\t\tsuper(params, debug);\n\t\tthis.toggled = false;\n\t}\n\n\ttoggle(state) {\n\t\tif (!state) this.toggled = !this.toggled;\n\t\telse this.toggled = state == 'on' ? true : false;\n\t\tthis.animation.state = this.toggled ? 'selected' : 'idle';\n\t\tif (this.func) this.func();\n\t\tthis.waitToGoOut = false;\n\t\tthis.mouseOver = false;\n\t\tthis.clickStarted = false;\n\t}\n\n\tout(x, y) {\n\t\tsuper.out(x, y);\n\t\tthis.animation.state = this.toggled ? 'selected' : 'idle';\n\t}\n\t\n\tup(x, y) {\n\t\tsuper.up();\n\t\tif (this.tap(x,y) && this.clickStarted) this.toggle();\n\t}\n}"]}