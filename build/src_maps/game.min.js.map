{"version":3,"sources":["Sprite.js","UI.js","Button.js","Entity.js","Events.js","Game.js","GameAnim.js","Manager.js","Scene.js","SceneManager.js","SpriteCollection.js","Stats.js","Text.js","TextButton.js","Texture.js","Toggle.js"],"names":["Sprite","[object Object]","x","y","w","h","animation","callback","this","position","Cool","Vector","size","debug","debugColor","collider","isActive","center","addAnimation","mouseOver","waitToGoOut","clickStarted","width","height","xy","copy","subtract","divide","gme","ctx","lineWidth","beginPath","rect","temp","strokeStyle","stroke","isOnScreen","drawDebug","draw","update","displayFunc","other","next","nextCollider","add","velocity","nextSize","tap","onOver","onOut","onDown","onUp","onClick","func","UI","params","super","hidden","states","state","scenes","window","Button","over","out","down","up","Entity","origin","offset","Events","init","canvas","dragOffset","dragStarted","addEventListener","ev","preventDefault","mouseClicked","offsetX","offsetY","mouseDown","which","shiftKey","startDrag","mouseUp","mouseMoved","drag","document","keyDown","target","tagName","keys","keyUp","sizeCanvas","Game","getElementById","lps","mixedColors","drawTime","performance","now","drawInterval","updateTime","updateInterval","clearBg","bounds","top","bottom","left","right","SceneManager","Scene","data","anims","getContext","dpr","checkRetina","devicePixelRatio","scale","style","zoom","lineColor","stats","Stats","create","miterLimit","files","assetsLoaded","numFiles","Object","length","f","file","fetch","then","response","ok","url","includes","text","json","Error","entries","key","loadJSON","src","csv","CSVToArray","splice","i","itemName","catch","error","console","loader","setInterval","loaded","k","clearInterval","start","GameAnim","loadData","requestAnimFrame","time","clearRect","dir","value","LinesAnimation","loop","randomFrames","isPlaying","currentFrame","currentState","end","currentFrameCounter","intervalRatio","Math","floor","prevFrame","frame","randomInt","onUpdate","frame4","onPlayedOnce","undefined","onPlayedState","label","_state","Manager","list","_class","_current","current","displaySprites","SpriteCollection","updateSprites","uiSprites","sprite","type","types","index","indexOf","all","display","item","addToDisplay","addUI","sprites","push","count","startTime","stat","round","fillStyle","fillRect","font","fillText","Text","msg","wrap","letters","letterIndexString","lead","track","breaks","setBreaks","hover","indexString","createNewState","breakOnNextSpace","prevBreak","match","countForward","countBackward","_x","_y","len","letter","TextButton","setCollider","setMsg","setPosition","Texture","locations","loc","randomIndex","endFrame","Toggle","toggled","toggle"],"mappings":"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","file":"../game.min.js","sourcesContent":["/*\n\tbase class for all game objects\n\tusually has an animation\n\tphysics and scaling removed in recent version\n*/\n\nclass Sprite {\n\tconstructor(x, y, w, h, animation, callback) {\n\t\tthis.position = new Cool.Vector(x, y);\n\t\tthis.size = new Cool.Vector(w, h);\n\t\tthis.debug = false;\n\t\tthis.debugColor = \"#00ffbb\";\n\t\tthis.collider = {\n\t\t\tposition: new Cool.Vector(0, 0),\n\t\t\tsize: new Cool.Vector(w, h)\n\t\t};\n\t\tthis.isActive = true;  // need a better name for this - disabled or something ... \n\t\tthis.center = false;\n\n\t\tif (animation) this.addAnimation(animation, callback);\n\n\t\tthis.mouseOver = false;\n\t\tthis.waitToGoOut = false;\n\t\tthis.clickStarted = false;\n\t\t// onOver, onOut, onUp, onDown, onClick\n\t}\n\n\tget width() {\n\t\treturn this.size.x;\n\t}\n\n\tget height() {\n\t\treturn this.size.y;\n\t}\n\n\tget xy() {\n\t\treturn this.center ? this.position.copy().subtract(this.size.copy().divide(2)) : this.position;\n\t}\n\n\tget x() {\n\t\treturn this.xy.x;\n\t}\n\n\tget y() {\n\t\treturn this.xy.y;\n\t}\n\n\taddAnimation(animation, callback) {\n\t\tthis.animation = animation;\n\t\tthis.size.x = this.collider.size.x = this.animation.width;\n\t\tthis.size.y = this.collider.size.y = this.animation.height;\n\t}\n\n\tsetCollider(x, y, w, h) {\n\t\tthis.collider.position.x = x;\n\t\tthis.collider.position.y = y;\n\t\tthis.collider.size.x = w;\n\t\tthis.collider.size.y = h;\n\t}\n\n\tdrawDebug() {\n\t\tgme.ctx.lineWidth = 1;\n\t\tgme.ctx.beginPath();\n\t\tgme.ctx.rect(\n\t\t\tthis.x + this.collider.position.x,\n\t\t\tthis.y + this.collider.position.y,\n\t\t\tthis.collider.size.x, \n\t\t\tthis.collider.size.y\n\t\t);\n\t\tconst temp = gme.ctx.strokeStyle;\n\t\tgme.ctx.strokeStyle = this.debugColor;\n\t\tgme.ctx.stroke();\n\t\tgme.ctx.strokeStyle = temp;\n\t}\n\n\tdisplay() {\n\t\tif (this.isActive && this.isOnScreen()) {\n\t\t\tif (this.debug) this.drawDebug();\n\t\t\tif (this.animation) {\n\t\t\t\tthis.animation.draw(this.x, this.y);\n\t\t\t\tthis.animation.update();\n\t\t\t}\n\t\t}\n\t\tif (this.displayFunc) this.displayFunc();\n\t}\n\n\tisOnScreen() {\n\t\tif (this.x + this.width > 0 && \n\t\t\tthis.y + this.height > 0 &&\n\t\t\tthis.x < gme.width &&\n\t\t\tthis.y < gme.height)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t} \n\n\ttap(x, y) {\n\t\tif (x > this.x + this.collider.position.x &&\n\t\t\tx < this.x + this.collider.position.x + this.collider.size.x && \n\t\t\ty > this.y + this.collider.position.y && \n\t\t\ty < this.y + this.collider.position.y + this.collider.size.y) {\n\t\t\treturn true;\n\t\t} else \n\t\t\treturn false;\n\t}\n\n\tcollide(other, callback) {\n\t\tif (this.isActive && other.isActive) {\n\t\t\tif (this.x + this.collider.position.x < other.x + other.collider.position.x + other.collider.size.x &&\n\t\t\t\tthis.x + this.collider.position.x + this.collider.size.x > other.x + other.collider.position.x &&\n\t\t\t\tthis.y + this.collider.position.y < other.y + other.collider.position.y + other.collider.size.y &&\n\t\t\t\tthis.y + this.collider.position.y + this.collider.size.y > other.y + other.collider.position.y) {\n\t\t\t\tif (callback) callback(this);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\toutside(other) {\n\t\tvar next = this.position.copy();\n\t\tvar nextCollider = this.collider.position.copy();\n\t\tnext.add(nextCollider);\n\t\tnext.add(this.velocity);\n\t\tvar nextSize = this.collider.size.copy();\n\t\tif (next.x < other.position.x + other.collider.position.x ||\n\t\t\tnext.x + nextSize.x > other.position.x + other.collider.position.x + other.collider.size.x ||\n\t\t\tnext.y < other.position.y + other.collider.position.y ||\n\t\t\tnext.y + nextSize.y > other.position.y + other.collider.position.y + other.collider.size.y) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tover(x, y) {\n\t\t// console.log(x, y);\n\t\t// console.log(this.tap(x, y));\n\t\tif (this.isActive && this.tap(x,y) && !this.mouseOver && !this.waitToGoOut) {\n\t\t\tthis.mouseOver = true;\n\t\t\tif (this.onOver) this.onOver();\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tout(x, y) {\n\t\tif (this.isActive && !this.tap(x,y) && (this.mouseOver || this.waitToGoOut)) {\n\t\t\tthis.clickStarted = false;\n\t\t\tthis.waitToGoOut = false;\n\t\t\tthis.mouseOver = false;\n\t\t\tif (this.onOut) this.onOut();\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdown(x, y) {\n\t\tif (this.isActive && this.tap(x,y)) {\n\t\t\tthis.clickStarted = true;\n\t\t\tthis.waitToGoOut = true;\n\t\t\tif (this.onDown) this.onDown();\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tup(x, y) {\n\t\tif (this.isActive && this.tap(x,y) && this.clickStarted) {\n\t\t\tthis.mouseOver = false;\n\t\t\tif (this.onUp) this.onUp();\n\t\t\tif (this.onClick) this.onClick();\n\t\t\tif (this.func) func();\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tthis.clickStarted = false;\n\t}\n}\n","/*\n\tpositions sprites relative to game canvas dimensions\n*/\n\nclass UI extends Sprite {\n\tconstructor(params, debug) {\n\t\t/* xy orientation to game window */\n\t\tlet x = params.x;\n\t\tlet y = params.y;\n\t\tif (x % 1 != 0) x = gme.width * x; /* decimal / percentage of window */\n\t\tif (x < 0) x = gme.width + x; /* negative x offset from right side */\n\t\tif (y % 1 != 0) y = gme.height * y; /* decimal / percentage of window */\n\t\tif (y < 0) y = gme.height + y; /* negative y offset from bottom */\n\t\t\n\t\tsuper(x, y);\n\t\tthis.debug = debug;\n\t\tthis.center = true;\n\n\t\tif (params.hidden) this.isActive = false; /* hidden prob in garden json ...  */\n\t\tif (params.animation) this.addAnimation(params.animation);\n\t\tif (params.states) {\n\t\t\tthis.animation.states = params.states;\n\t\t\tthis.animation.state = 'idle';\n\t\t}\n\n\t\tthis.scenes = params.scenes; // deprecate ? \n\t\t\n\t\tif (params.func) this.func = window[params.func]; \n\t\t/* shouldnt be attached to window - fine for now */\n\t}\n}\n","/*\n\tSprite -> UI -> Button\n*/\n\nclass Button extends UI {\n\tconstructor(params, debug) {\n\t\tsuper(params, debug);\n\n\t\tthis.mouseOver = false;\n\t\tthis.waitToGoOut = false;\n\t\tthis.clickStarted = false;\n\n\t\tif (params.onOver) this.onOver = params.onOver;\n\t\tif (params.onOut) this.onOut = params.onOut;\n\t\tif (params.onDown) this.onDown = params.onDown;\n\t\tif (params.onClick) this.onClick = params.onClick;\n\t}\n\n\tover(x, y) {\n\t\tconst over = super.over(x, y);\n\t\tif (over) this.animation.state = 'over';\n\t\treturn over;\n\t}\n\n\tout(x, y) {\n\t\tconst out = super.out(x, y);\n\t\tif (out) this.animation.state = 'idle';\n\t\treturn out;\n\t}\n\n\tdown(x, y) {\n\t\tconst down = super.down(x, y);\n\t\tif (down)  this.animation.state = 'active';\n\t\treturn down;\n\t}\n\n\tup(x, y) {\n\t\tconst up = super.up(x, y);\n\t\tif (up) this.animation.state = 'idle';\n\t\treturn up;\n\t}\n}","/*\n\tSprite -> Entity\n\tEntity is basically anything that appears on the map\n\tneeds to be updated by offset generated in game map\n\n\tsprite position is draw position - origin + offset\n\torigin is really map position\n*/\n\nclass Entity extends Sprite {\n\tconstructor(params, debug) {\n\t\tsuper(params.x, params.y);\n\t\tthis.debug = debug;\n\t\tthis.origin = new Cool.Vector(params.x, params.y);\n\t\t// this.origin = { x: params.x, y: params.y };\n\n\t\tthis.center = params.center || true;\n\t}\n\n\tupdate(offset) {\n\t\t/* simpler than vectors */\n\t\tthis.position.x = this.origin.x + offset.x;\n\t\tthis.position.y = this.origin.y + offset.y;\n\t}\n\n\tsetPosition(x, y) {\n\t\tthis.origin.x = x;\n\t\tthis.origin.y = y;\n\t}\n}","const Events = {\n\tinit: function(canvas) {\n\n\t\tvar startX, startY, endX, endY, startTime;\n\t\tvar dragStarted = false;\n\t\tvar dragOffset;\n\n\t\tcanvas.addEventListener('click', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\t\n\t\t\tif (typeof mouseClicked === \"function\") \n\t\t\t\tmouseClicked(ev.offsetX, ev.offsetY);\n\t\t}, false);\n\n\t\tcanvas.addEventListener('mousedown', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tif (typeof mouseDown === \"function\") \n\t\t\t\tmouseDown(ev.offsetX, ev.offsetY, ev.which, ev.shiftKey);\n\t\t\tif (typeof startDrag === \"function\") {\n\t\t\t\tdragOffset = startDrag(ev.offsetX, ev.offsetY);\n\t\t\t\tif (dragOffset) dragStarted = true;\n\t\t\t}\n\t\t}, false);\n\n\t\tcanvas.addEventListener('mouseup', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tif (typeof mouseUp === \"function\") \n\t\t\t\tmouseUp(ev.offsetX, ev.offsetY, ev.which);\n\t\t\tif (dragStarted) dragStarted = false;\n\t\t}, false);\n\n\t\tcanvas.addEventListener('mousemove', function(ev) {\n\t\t\tif (typeof mouseMoved === \"function\") \n\t\t\t\tmouseMoved(ev.offsetX, ev.offsetY, ev.which);\n\t\t\tif (dragStarted) \n\t\t\t\tdrag(ev.offsetX, ev.offsetY, dragOffset);\n\t\t}, false);\n\n\t\tdocument.addEventListener('keydown', function(ev) {\n\t\t\tif (typeof keyDown === \"function\" && ev.target.tagName != \"INPUT\") \n\t\t\t\tkeyDown(Cool.keys[ev.which]);\n\t\t});\n\n\t\tdocument.addEventListener('keyup', function(ev) {\n\t\t\tif (typeof keyUp === \"function\" && ev.target.tagName != \"INPUT\") \n\t\t\t\tkeyUp(Cool.keys[ev.which]);\n\t\t});\n\n\t\twindow.addEventListener('resize', function(ev) {\n\t\t\tif (typeof sizeCanvas === \"function\") sizeCanvas();\n\t\t}, false);\n\t}\n}","class Game {\n\tconstructor(params) {\n\t\tthis.canvas = document.getElementById(params.canvas || \"lines\");\n\n\t\tthis.width = params.width;\n\t\tthis.height = params.height;\n\t\tthis.lps = params.lps;\n\t\tthis.mixedColors = params.mixedColors || false; /* param? */\n\t\tthis.debug = params.debug || false;\n\n\t\tthis.drawTime = performance.now();\n\t\tthis.drawInterval = 1000 / params.lps;\n\n\t\tthis.updateTime = this.drawTime;\n\t\tthis.updateInterval = 1000 / 60; // 60 fps\n\n\t\tthis.clearBg = true;\n\t\tthis.bounds = { top: 0, bottom: 0, left: 0, right: 0 };\n\n\t\tthis.scenes = new SceneManager(params.scenes, Scene);\n\n\t\tthis.data = {};\n\t\tthis.anims = {};\n\n\t\tif (this.canvas.getContext) {\n\t\t\tthis.ctx = this.canvas.getContext('2d');\n\t\t\tthis.dpr = params.checkRetina ? window.devicePixelRatio || 1 : 1;\n\n\t\t\tthis.canvas.width = this.width * this.dpr;\n\t\t\tthis.canvas.height = this.height * this.dpr;\n\t\t\tthis.ctx.scale(this.dpr, this.dpr);\n\t\t\tthis.canvas.style.zoom = 1 / this.dpr;\n\n\t\t\tif (params.lineColor) this.ctx.strokeStyle = params.lineColor;\n\t\t\tif (params.scale) this.ctx.scale(params.scale, params.scale);\n\n\t\t\tif (params.stats) {\n\t\t\t\tthis.stats = new Stats(this.ctx, params.width);\n\t\t\t\tthis.stats.create('FPS', this.updateTime);\n\t\t\t\tthis.stats.create('draw', this.drawTime);\n\t\t\t}\n\n\t\t\tthis.ctx.miterLimit = 1; // do this last\n\t\t}\n\t}\n\n\tload(files, callback) {\n\t\tthis.assetsLoaded = {};\n\t\tconst numFiles = Object.keys(files).length;\n\t\tfor (const f in files) {\n\t\t\tconst file = files[f];\n\t\t\tfetch(file)\n\t\t\t\t.then(response => {\n\t\t\t\t\tif (response.ok) return response.url.includes('csv') ? response.text() : response.json();\n\t\t\t\t\tthrow new Error('Network response was not ok.');\n\t\t\t\t})\n\t\t\t\t.then(data => {\n\t\t\t\t\tthis.data[f] = {};\n\t\t\t\t\tthis.anims[f] = {};\n\t\t\t\t\tthis.assetsLoaded[f] = {};\n\t\t\t\t\tif (typeof data == 'object') {\n\t\t\t\t\t\tthis.data[f].entries = data;\n\t\t\t\t\t\tfor (const key in data) {\n\t\t\t\t\t\t\tthis.assetsLoaded[f][key] = false;\n\t\t\t\t\t\t\tthis.loadJSON(f, key, data[key].src);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// csv item names have to match drawing names\n\t\t\t\t\t\tconst csv = CSVToArray(data, ',').splice(1);\n\t\t\t\t\t\tthis.data[f].entries = csv;\n\t\t\t\t\t\tfor (let i = 0; i < csv.length; i++) {\n\t\t\t\t\t\t\tconst itemName = csv[i][0];\n\t\t\t\t\t\t\tthis.assetsLoaded[f][itemName] = false;\n\t\t\t\t\t\t\tthis.loadJSON(f, itemName, `drawings/${f}/${itemName}.json`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(error => {\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t\tthis.assetsLoaded[f] = true;\n\t\t\t\t});\n\t\t}\n\n\t\tconst loader = setInterval(() => {\n\t\t\tlet loaded = Object.keys(this.assetsLoaded).length == numFiles;\n\t\t\tfor (const f in this.assetsLoaded) {\n\t\t\t\tfor (const k in this.assetsLoaded[f]) {\n\t\t\t\t\tif (!this.assetsLoaded[f][k]) loaded = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (loaded) {\n\t\t\t\tclearInterval(loader);\n\t\t\t\t// when will this ever not be game start?\n\t\t\t\t// if (callback) callback();\n\t\t\t\tthis.start();\n\t\t\t}\n\t\t}, 1000 / 60);\n\t}\n\n\tloadJSON(file, key, src) {\n\t\tfetch(src)\n\t\t\t.then(response => { return response.json(); })\n\t\t\t.then(json => {\n\t\t\t\tthis.anims[file][key] = new GameAnim();\n\t\t\t\tthis.anims[file][key].loadData(json, () => {\n\t\t\t\t\tthis.assetsLoaded[file][key] = true;\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\tstart() {\n\t\t/* \n\t\t\tdraw and update are separates functions \n\t\t\tbecause lines draw at relatively slow rate (10fps) \n\t\t*/\n\t\tif (typeof start === \"function\") start(); // should be this method?\n\t\t\n\t\tif (typeof update === \"function\") requestAnimFrame(() => { this.update() });\n\t\t// if (typeof draw === \"function\") requestAnimFrame(() => { this.draw() });\n\n\t\t// better way to do events? \n\t\tif (typeof Events != \"undefined\") Events.init(this.canvas);\n\t}\n\n\tdraw(time) {\n\t\tif (this.clearBg) this.ctx.clearRect(0, 0, this.width * this.dpr, this.height * this.dpr);\n\n\t\t// add draw scenes ? \n\n\t\tdraw(); // draw defined in each this js file, or not ... \n\t\tif (this.stats) {\n\t\t\tthis.stats.update('draw', time);\n\t\t\tthis.stats.draw();\n\t\t}\n\t\tthis.drawTime = time - ((time - this.drawTime) % this.drawInterval);\n\t}\n\n\tupdate() {\n\t\trequestAnimFrame(() => { this.update(); });  // this context\n\n\t\tconst time = performance.now();\n\t\tif (time > this.updateTime + this.updateInterval) {\n\t\t\tupdate(); // update defined in each game js file\n\t\t\tthis.updateTime = time - ((time - this.updateTime) % this.updateInterval); // adjust for fps interval being off\n\t\t\tif (this.stats) this.stats.update('FPS', time);\n\t\t\t\n\t\t}\n\t\tif (time > this.drawTime + this.drawInterval) this.draw(time);\n\t}\n\n\tsetBounds(dir, value) {\n\t\tthis.bounds[dir] = value;\n\t}\n}","class GameAnim extends LinesAnimation {\n\tconstructor(src, callback, debug) {\n\t\tsuper(gme.ctx, gme.lps, gme.mixedColors);\n\t\tthis.debug = debug;\n\t\tthis.loop = true;\n\t\tthis.randomFrames = false; /* play random frames */\n\t}\n\n\tupdate() { /* too many things to stick in onPlayedState etc */\n\t\tif (this.isPlaying) {\n\t\t\tif (this.currentFrame <= this.currentState.end) {\n\t\t\t\tthis.currentFrameCounter += this.intervalRatio;\n\t\t\t\tif (this.randomFrames && this.currentFrame != Math.floor(this.currentFrameCounter)) {\n\t\t\t\t\tconst prevFrame = this.currentFrame;\n\t\t\t\t\twhile (prevFrame == this.currentFrame) {\n\t\t\t\t\t\tthis.frame = Cool.randomInt(this.currentState.start, this.currentState.end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.currentFrame = Math.floor(this.currentFrameCounter);\n\t\t\t\tif (this.onUpdate) this.onUpdate();\n\t\t\t}\n\t\t}\n\n\t\tif (this.frame4 >= this.currentState.end + 1) { /* not DRY fuck me */\n\t\t\tif (this.loop) this.frame = this.currentState.start;\n\t\t\telse this.frame = this.currentState.end;\n\t\t\tif (this.onPlayedOnce) {\n\t\t\t\tthis.onPlayedOnce();\n\t\t\t\tthis.onPlayedOnce = undefined;\n\t\t\t}\n\t\t\tif (this.onPlayedState) this.onPlayedState();\n\t\t}\n\t}\n\n\tcreateNewState(label, start, end) {\n\t\tif (!this.states[label]) {\n\t\t\tthis.states[label] = {\n\t\t\t\tstart: start,\n\t\t\t\tend: end\n\t\t\t}\n\t\t}\n\t\tthis.state = label; /* ? */\n\t}\n\n\tset state(state) {\n\t\tif (this._state != state && this.states[state]) {\n\t\t\tthis._state = state;\n\t\t\tif (this.currentState) this.frame = this.currentState.start;\n\t\t\tif (!this.isPlaying && state != 'default') this.isPlaying = true; \n\t\t}\n\t}\n\n\tget state() {\n\t\treturn this._state;\n\t}\n\n\tplayOnce(callback) {\n\t\tif (!this.isPlaying) this.isPlaying = true;\n\t\tthis.frame = this.currentState.start;\n\t\tthis.onPlayedOnce = callback;\n\t}\n\n\tstop() {\n\t\tthis.isPlaying = false;\n\t}\n\n\tstart() {\n\t\tthis.isPlaying = true;\n\t}\n}","/*\n\tused for scenes: gme.scenes, gme.scenes.current etc\n\tcould also be implemented for animation states, other things with states\n\tbasically allows you to set with a string and get an object\n*/\n\nclass Manager {\n\tconstructor(list, _class) {\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tthis[list[i]] = new _class();\n\t\t}\n\t\tthis._current = list[0];\n\t}\n\n\tset current(label) {\n\t\tthis._current = label;\n\t}\n\n\tget current() {\n\t\treturn this[this._current];\n\t}\n\n}","class Scene {\n\tconstructor() {\n\t\tthis.displaySprites = new SpriteCollection();\n\t\tthis.updateSprites = new SpriteCollection();\n\t\tthis.uiSprites = new SpriteCollection();\n\t}\n\n\tadd(sprite) {\n\t\tthis.displaySprites.add(sprite);\n\t\tthis.updateSprites.add(sprite);\n\t\tthis.uiSprites.add(sprite);\n\t}\n\n\tremove(sprite, type) {\n\t\tconst types = type ? [type] : ['display', 'update', 'ui'];\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tconst index = this[`${types[i]}Sprites`].indexOf(sprite);\n\t\t\tif (index >= 0) this[`${types[i]}Sprites`].splice(index, 1);\n\t\t}\n\t}\n\n\taddSprite(sprite) {\n\t\tthis.displaySprites.add(sprite);\n\t\tthis.updateSprites.add(sprite);\n\t}\n\n\taddUI(sprite) {\n\t\tthis.displaySprites.add(sprite);\n\t\tthis.uiSprites.add(sprite);\n\t}\n\n\taddToDisplay(sprite) {\n\t\tthis.displaySprites.add(sprite);\n\t}\n\n\taddToUpdate(sprite) {\n\t\tthis.updateSprites.add(sprite);\n\t}\n\n\taddToUI(sprite) {\n\t\tthis.uiSprites.add(sprite);\n\t}\n\n\tdisplay() {\n\t\tthis.displaySprites.all(sprite => { sprite.display() });\n\t}\n\n\tupdate() {\n\t\tthis.updateSprites.all(sprite => { sprite.update() });\n\t}\n\n\tmouseMoved(x, y) {\n\t\tthis.uiSprites.all(sprite => {\n\t\t\tsprite.over(x, y);\n\t\t\tsprite.out(x, y);\n\t\t});\n\t}\n\n\tmouseDown(x, y) {\n\t\tthis.uiSprites.all(sprite => { sprite.down(x, y); });\n\t}\n\n\tmouseUp(x, y) {\n\t\tthis.uiSprites.all(sprite => { sprite.up(x, y); });\n\t}\n}","class SceneManager extends Manager {\n\tadd(item, scenes, which) {\n\t\tif (typeof scenes == 'string') scenes = [scenes];\n\t\tfor (let i = 0; i < scenes.length; i++) {\n\t\t\tif (which == 'display') this[scenes[i]].addToDisplay(item);\n\t\t\telse if (which == 'ui') this[scenes[i]].addUI(item)\n\t\t\telse this[scenes[i]].add(item);\n\t\t}\n\t}\n}","/*\n\tused mostly by SceneManager to handle sprites for each scene\n\talso used by game asset managers like pack or map\n*/\n\nclass SpriteCollection {\n\tconstructor(sprites) {\n\t\tthis.sprites = sprites ? [...sprites] : [];\n\t}\n\n\tget length() {\n\t\treturn this.sprites.length;\n\t}\n\n\tsprite(index) {\n\t\treturn this.sprites[index];\n\t}\n\n\tremove(sprite) {\n\t\tthis.sprites.splice(this.sprites.indexOf(sprite), 1);\n\t}\n\n\tadd(sprite) {\n\t\tthis.sprites.push(sprite);\n\t}\n\n\t// loop \n\tall(callback) {\n\t\tfor (let i = 0; i < this.sprites.length; i++) {\n\t\t\tcallback(this.sprites[i], i);\n\t\t}\n\t}\n\n\tdisplay() {\n\t\tthis.all(sprite => { sprite.display(); });\n\t}\n}","/*\n\tstill figuring this out\n\trn just fps and draw/sec\n\twant to add millis\n*/\n\nclass Stats {\n\tconstructor(ctx, width) {\n\t\tthis.ctx = ctx;\n\t\tthis.width = width;\n\t\tthis.stats = {};\n\t}\n\n\tcreate(label, time) {\n\t\tthis.stats[label] = {\n\t\t\tcount: 0,\n\t\t\tstartTime: time,\n\t\t\tvalue: 0\n\t\t}\n\t}\n\n\tupdate(label, time) {\n\t\t// this.stats[label].push(time);\n\t\t// if (this.stats[label].length > 20) this.stats[label].shift();\n\t\n\t\tconst stat = this.stats[label];\n\t\t// if (label == 'draw') console.log(time, stat.startTime, stat.count);\n\t\tstat.count++;\n\t\tstat.value = Math.round(1000 / ((time - stat.startTime) / stat.count) * 100) / 100;\n\t}\n\n\tdraw() {\n\t\t// bg\n\t\tthis.ctx.fillStyle = 'rgba(0,0,0,0.75)';\n\t\tthis.ctx.fillRect(this.width - 65, 0, 60, 40);\n\n\t\tthis.ctx.font = 'lighter 11px sans-serif';\n\t\tthis.ctx.fillStyle = 'rgba(100,255,200)';\n\n\t\tlet x = this.width - 60;\n\t\tlet y = 15;\n\n\t\tfor (const label in this.stats) {\n\t\t\tconst stat = this.stats[label];\n\t\t\tthis.ctx.fillText(`${label} ${stat.value}`, x, y);\n\t\t\ty += 20;\n\t\t}\n\t}\n}","/*\n\tdraws text with lettering based on game text string\n\thandled by game so that each new text object doesn't have to add all the letters...\n\tmaybe just check first?\n*/\n\nclass Text {\n\tconstructor(x, y, msg, wrap, letters, letterIndexString) {\n\t\tthis.x = Math.round(x);\n\t\tthis.y = Math.round(y);\n\t\tthis.lead = 35; // leading is space between lines\n\t\tthis.track = 18; // tracking is space between letters\n\t\tthis.msg = msg;\n\t\tthis.wrap = wrap;\n\t\tthis.isActive = true;\n\t\tthis.letters = letters;\n\t\tthis.breaks = [];\n\t\tthis.setBreaks();\n\t\tthis.count = 0;\n\t\tthis.end = 0;\n\t\tthis.hover = false;\n\t\tthis.clickStarted = false;\n\n\t\tif (!letters.states[0]) {\n\t\t\tconst indexString = letterIndexString || \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,:?-+'&$;\\\"!\";\n\t\t\tfor (let i = 0; i < indexString.length; i++) {\n\t\t\t\tletters.createNewState(indexString[i], i, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetPosition(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tsetMsg(msg) {\n\t\tthis.msg = msg;\n\t\tthis.setBreaks();\n\t}\n\n\tsetBreaks() {\n\t\t/* \n\t\t\tset line breaks in message, \n\t\t\tbased on message length, new line & return keys\n\t\t\twaits for a space i guess?\n\t\t*/\n\n\t\tlet breakOnNextSpace = false; // wait for next space character\n\t\tlet offset = 0; // 0 matches first i % this.wrap, then moves to accomodate added characters for spaces\n\t\tlet prevBreak = false; // for space break followed by \\n\\r\n\t\tthis.breaks = [];\n\n\t\tfor (let i = 1; i < this.msg.length; i++) {\n\t\t\tprevBreak = false;\n\n\t\t\t// break on \\n\\r, check to make sure it didn't just break\n\t\t\tif (this.msg[i].match(/[\\n\\r]/g) && !prevBreak) {\n\t\t\t\tthis.breaks.push(i);\n\t\t\t\toffset = i % this.wrap;\n\t\t\t\tbreakOnNextSpace = false;\n\t\t\t}\n\n\t\t\telse if (i % this.wrap == offset && !breakOnNextSpace) {\n\t\t\t\tif (this.msg[i] == ' ') {\n\t\t\t\t\tthis.breaks.push(i);\n\t\t\t\t\tprevBreak = true;\n\t\t\t\t}\n\t\t\t\telse breakOnNextSpace = true;\n\t\t\t}\n\n\t\t\telse if (this.msg[i] == ' ' && breakOnNextSpace) {\n\t\t\t\tthis.breaks.push(i);\n\t\t\t\toffset = i % this.wrap;\n\t\t\t\tbreakOnNextSpace = false;\n\t\t\t\tprevBreak = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/* animate text backward and forward, maybe need to update - maybe add animate/update method? */\n\tdisplay(countForward, countBackward, _x, _y) {\n\t\tif (this.isActive) {\n\t\t\tconst len = countForward ? this.count : this.msg.length;\n\t\t\tconst index = countBackward ? this.end : 0;\n\t\t\tlet x = _x || this.x;\n\t\t\tlet y = _y || this.y;\n\t\t\t// y -= this.breaks.length * this.lead;\n\t\t\tfor (let i = index; i < len; i++) {\n\t\t\t\tvar letter = this.msg[i];\n\t\t\t\t// if (!letter.match(/[!a-zA-Z]/g)) console.log(letter);\n\t\t\t\tif (letter == ' ' || letter == '_') {\n\t\t\t\t\tx += this.track;\n\t\t\t\t} else if (letter == '\\n' || letter == '\\r') {\n\t\t\t\t\t// y += this.lead;\n\t\t\t\t\t// x = _x || this.x;\n\t\t\t\t} else {\n\t\t\t\t\tthis.letters.state = letter;\n\t\t\t\t\tthis.letters.draw(x, y);\n\t\t\t\t\tx += this.track;\n\t\t\t\t}\n\t\t\t\tif (this.breaks.indexOf(i) != -1) {\n\t\t\t\t\ty += this.lead;\n\t\t\t\t\tx = _x || this.x;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (this.count >= this.msg.length) this.end++;\n\t\t\telse this.count++;\n\t\t\tif (countBackward) {\n\t\t\t\tif (this.end >= this.msg.length) {\n\t\t\t\t\tthis.end = 0; /* reset */\n\t\t\t\t\tthis.count = 0;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.end >= 5) { // how long to wait after completed text // hardcoded?\n\t\t\t\t\tthis.end = 0;\n\t\t\t\t\tthis.count = 0;\n\t\t\t\t\treturn true; // ended\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n","/*\n\tSprite -> UI -> TextButton\n\ta ui sprite that has text to render instead of animation\n*/\n\nclass TextButton extends UI {\n\tconstructor(x, y, msg, wrap, letters) {\n\t\tsuper({x: x, y: y});\n\t\tthis.center = false;\n\t\tthis.text = new Text(this.position.x, this.position.y, msg, wrap, letters);\n\t\tthis.setCollider();\n\t}\n\n\tsetMsg(msg) {\n\t\tthis.text.setMsg(msg);\n\t\tthis.text.wrap = msg.length;\n\t\tthis.setCollider();\n\t}\n\n\tsetCollider() {\n\t\tthis.size.x = this.collider.size.x = (this.text.wrap < this.text.msg.length ? this.text.wrap : this.text.msg.length) * this.text.track;\n\t\tthis.size.y = this.collider.size.y = (this.text.breaks.length + 1) * this.text.letters.height;\n\t}\n\n\tdisplay() {\n\t\tsuper.display();\n\t\tif (this.isActive) this.text.display();\n\t}\n\n\tsetPosition(x, y) {\n\t\tthis.position.x = x;\n\t\tthis.position.y = y;\n\t\tthis.text.setPosition(x, y);\n\t}\n}","/*\n\tdraws frames from one animation in multuple places (locations)\t\n*/\n\nclass Texture {\n\tconstructor(params, debug) {\n\t\tthis.locations = params.locations || [];\n\t\tthis.frame = params.frame || 'index';\n\t\tthis.debug = debug;\n\t\tthis.center = params.center || false;\n\t\t\n\t\tthis.offset = new Cool.Vector(0, 0);\n\t\tif (params.animation) this.animation = params.animation;\n\t}\n\n\taddLocation(index, x, y) {\n\t\tthis.animation.createNewState(`f-${index}`, index, index);\n\t\tconst loc = new Cool.Vector(x, y);\n\t\tloc.i = index;\n\t\tthis.locations.push(loc);\n\t}\n\n\taddLocations(locations) {\n\t\tthis.locations.push(...locations);\n\t\tfor (let i = 0; i < this.locations.length; i++) {\n\t\t\tif (this.frame == 'index') {\n\t\t\t\tthis.locations[i].i = i;\n\t\t\t\tthis.animation.createNewState(`f-${i}`, i, i);\n\t\t\t}\n\t\t\telse if (this.frame == 'random') {\n\t\t\t\tthis.animation.randomFrames = true;\n\t\t\t}\n\t\t\telse if (this.frame == 'randomIndex') {\n\t\t\t\tlet randomIndex = Cool.randomInt(0, this.animation.endFrame);\n\t\t\t\tthis.locations[i].i = randomIndex;\n\t\t\t\tthis.animation.createNewState(`f-${randomIndex}`, randomIndex, randomIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\tdisplay() {\n\t\tfor (let i = 0; i < this.locations.length; i++) {\n\t\t\tlet x = this.locations[i].x + this.offset.x;\n\t\t\tlet y = this.locations[i].y + this.offset.y;\n\t\t\tif (this.center) {\n\t\t\t\tx -= this.animation.width / 2;\n\t\t\t\ty -= this.animation.height / 2;\n\t\t\t}\n\n\t\t\t//  figure out centering later, only draw textures on screen\n\t\t\tif (x + this.animation.width > 0 && x < gme.width && y + this.animation.height > 0 && y < gme.height) {\n\t\t\t\tif (this.locations[i].i) this.animation.state = `f-${this.locations[i].i}`;\n\t\t\t\tthis.animation.draw(x, y);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate(offset) {\n\t\tthis.offset.x = offset.x;\n\t\tthis.offset.y = offset.y;\n\t}\n}","/*\n\tSprite -> UI -> Button -> Toggle\n\tbutton with added toggled state\n*/\n\nclass Toggle extends Button {\n\tconstructor(params, debug) {\n\t\tsuper(params, debug);\n\t\tthis.toggled = false;\n\t}\n\n\ttoggle(state) {\n\t\tif (!state) this.toggled = !this.toggled;\n\t\telse this.toggled = state == 'on' ? true : false;\n\t\tthis.animation.state = this.toggled ? 'selected' : 'idle';\n\t\tif (this.func) this.func();\n\t\tthis.waitToGoOut = false;\n\t\tthis.mouseOver = false;\n\t\tthis.clickStarted = false;\n\t}\n\n\tout(x, y) {\n\t\tsuper.out(x, y);\n\t\tthis.animation.state = this.toggled ? 'selected' : 'idle';\n\t}\n\t\n\tup(x, y) {\n\t\tsuper.up();\n\t\tif (this.tap(x,y) && this.clickStarted) this.toggle();\n\t}\n}"]}