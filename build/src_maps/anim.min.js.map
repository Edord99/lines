{"version":3,"sources":["LinesAnimation.js"],"names":["LinesAnimation","[object Object]","ctx","lps","mixedColors","this","loaded","isPlaying","drawings","layers","currentFrame","currentFrameCounter","fps","lineInterval","intervalRatio","rndr","off","x","y","speed","_state","states","default","start","end","over","override","_fps","_lps","frame","n","endFrame","frame4","toFixed","length","Math","max","apply","map","layer","f","e","state","prop","value","floor","onUpdate","onPlayedState","beginPath","i","len","drawing","d","s","key","t","j","tween","sf","ef","Cool","sv","ev","round","w","random","v","Vector","subtract","divide","moveTo","r","k","p","lineTo","ws","xy","strokeStyle","c","stroke","onDraw","src","callback","fetch","then","response","json","data","loadData","catch","error","console","point","push","l","mc","width","height","h","onLoad"],"mappings":"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","file":"../anim.min.js","sourcesContent":["class LinesAnimation {\n\tconstructor(ctx, lps, mixedColors) {\n\t\tthis.ctx = ctx;\n\t\tthis.loaded = false;\n\t\tthis.isPlaying = false;\n\t\tthis.drawings = [];\n\t\tthis.layers = [];\n\t\tthis.currentFrame = 0;\n\t\tthis.currentFrameCounter = 0; // floats\n\t\t\n\t\tthis.lps = lps || 12;\n\t\tthis.fps = lps || 12;\n\t\tthis.lineInterval = 1000 / this.lps;\n\t\tthis.intervalRatio = 1;\n\n\t\tthis.mixedColors = mixedColors || true;\n\t\t\n\t\tthis.rndr = {\n\t\t\toff: { x: 0, y: 0 },\n\t\t\tspeed: { x: 0, y: 0 }\n\t\t};\n\n\t\tthis._state = 'default'; // set state label\n\t\tthis.states = { 'default': {start: 0, end: 0 } };\n\n\t\tthis.over = {};\n\t\tthis.override = true;\n\t}\n\n\tset fps(fps) {\n\t\tthis._fps = +fps;\n\t\tthis.intervalRatio = this.lineInterval / (1000 / +fps);\n\t}\n\n\tget fps() {\n\t\treturn this._fps;\n\t}\n\n\tset lps(lps) {\n\t\tthis._lps = +lps;\n\t\tthis.lineInterval = 1000 / +lps;\n\t\tthis.intervalRatio = this.lineInterval / (1000 / this.fps);\n\t}\n\n\tget lps() {\n\t\treturn this._lps;\n\t}\n\n\tset frame(n) {\n\t\tthis.currentFrame = this.currentFrameCounter = +n;\n\t\tif (this.states.default) {\n\t\t\tif (this.states.default.end != this.endFrame)\n\t\t\t\tthis.states.default.end = this.endFrame;\n\t\t}\n\t}\n\n\tget frame4() {\n\t\treturn +this.currentFrameCounter.toFixed(4);\n\t}\n\n\tget endFrame() {\n\t\treturn this.layers.length > 0 ?\n\t\t\tMath.max.apply(Math, this.layers.map(layer => { return layer.f.e; }))\n\t\t\t: 0;\n\t}\n\n\tset state(state) {\n\t\tif (this._state != state && this.states[state]) {\n\t\t\tthis._state = state;\n\t\t\tif (this.state) this.frame = this.state.start;\n\t\t}\n\t}\n\n\tget state() {\n\t\treturn this.states[this._state];\n\t}\n\n\toverrideProperty(prop, value) {\n\t\tthis.over[prop] = value;\n\t\tthis.override = true;\n\t}\n\n\tcancelOverride() {\n\t\tthis.over = {}\n\t\tthis.override = false;\n\t}\n\n\tupdate() {\n\t\tif (this.isPlaying) {\n\t\t\tif (this.currentFrame <= this.state.end) {\n\t\t\t\tthis.currentFrameCounter += this.intervalRatio;\n\t\t\t\tthis.currentFrame = Math.floor(this.currentFrameCounter);\n\t\t\t\tif (this.onUpdate) this.onUpdate();\n\t\t\t}\n\n\t\t\t/* fuck me */\n\t\t\tif (this.frame4 >= this.state.end + 1) {\n\t\t\t\tthis.frame = this.state.start;\n\t\t\t\t/* loop ? */\n\t\t\t\tif (this.onPlayedState) this.onPlayedState();\n\t\t\t}\n\t\t\tif (this.onUpdate) this.onUpdate();\n\t\t}\n\t}\n\n\tdraw(x, y) {\n\t\t// if (this.debug) console.log(x, y);\n\t\tif (!this.mixedColors) this.ctx.beginPath();\n\t\tfor (let i = 0, len = this.layers.length; i < len; i++) {\n\t\t\tconst layer = this.layers[i];\n\t\t\tconst drawing = this.drawings[layer.d];\n\t\t\tif (this.currentFrame >= layer.f.s && this.currentFrame <= layer.f.e) {\n\t\t\t\tthis.rndr.s = 0;\n\t\t\t\tthis.rndr.e = drawing.length;\n\n\t\t\t\tfor (const key in layer) {\n\t\t\t\t\tthis.rndr[key] = layer[key];\n\t\t\t\t}\n\n\t\t\t\tif (x) this.rndr.x += x;\n\t\t\t\tif (y) this.rndr.y += y;\n\n\t\t\t\tif (layer.t) {\n\t\t\t\t\tfor (let j = 0; j < layer.t.length; j++) {\n\t\t\t\t\t\tconst tween = layer.t[j];\n\t\t\t\t\t\tif (tween.sf <= this.currentFrame && tween.ef >= this.currentFrame) {\n\t\t\t\t\t\t\tthis.rndr[tween.prop] = Cool.map(this.currentFrame, tween.sf, tween.ef, tween.sv, tween.ev);\n\t\t\t\t\t\t\tif (tween.prop == 's' || tween.prop == 'e')\n\t\t\t\t\t\t\t\tthis.rndr[tween.prop] = Math.round(this.rndr[tween.prop]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.override) {\n\t\t\t\t\tfor (const key in this.over) {\n\t\t\t\t\t\tthis.rndr[key] = this.over[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.rndr.w > 0) {\n\t\t\t\t\tthis.rndr.off.x = Cool.random(0, this.rndr.w); // random start of wiggle offset\n\t\t\t\t\tthis.rndr.off.y = Cool.random(0, this.rndr.w);\n\t\t\t\t\tthis.rndr.speed.x = Cool.random(-this.rndr.v, this.rndr.v);\n\t\t\t\t\tthis.rndr.speed.y = Cool.random(-this.rndr.v, this.rndr.v);\n\t\t\t\t} else {\n\t\t\t\t\tthis.rndr.off.x = 0;\n\t\t\t\t\tthis.rndr.off.y = 0;\n\t\t\t\t\tthis.rndr.speed.x = 0;\n\t\t\t\t\tthis.rndr.speed.y = 0;\n\t\t\t\t}\n\n\t\t\t\tif (this.mixedColors) this.ctx.beginPath();\n\t\t\t\tfor (let j = this.rndr.s; j < this.rndr.e - 1; j++) {\n\t\t\t\t\tconst s = drawing[j];\n\t\t\t\t\tconst e = drawing[j + 1];\n\t\t\t\t\tconst v = new Cool.Vector(e.x, e.y);\n\t\t\t\t\tv.subtract(s);\n\t\t\t\t\tv.divide(this.rndr.n);\n\t\t\t\t\tthis.ctx.moveTo(\n\t\t\t\t\t\tthis.rndr.x + s.x + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.x, \n\t\t\t\t\t\tthis.rndr.y + s.y + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.y\n\t\t\t\t\t);\n\t\t\t\t\tfor (let k = 0; k < this.rndr.n; k++) {\n\t\t\t\t\t\tconst p = new Cool.Vector(s.x + v.x * k, s.y + v.y * k);\n\t\t\t\t\t\tthis.ctx.lineTo( \n\t\t\t\t\t\t\tthis.rndr.x + p.x + v.x + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.x,\n\t\t\t\t\t\t\tthis.rndr.y + p.y + v.y + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.y\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (k == 0 || this.rndr.ws) {\n\t\t\t\t\t\t\tif (this.rndr.w > 0) {\n\t\t\t\t\t\t\t\tfor (const xy in this.rndr.off) {\n\t\t\t\t\t\t\t\t\tthis.rndr.off[xy] += this.rndr.speed[xy];\n\t\t\t\t\t\t\t\t\tif (this.rndr.off[xy] >= this.rndr.w || \n\t\t\t\t\t\t\t\t\t\tthis.rndr.off[xy] <= -this.rndr.w) {\n\t\t\t\t\t\t\t\t\t\tthis.rndr.speed[xy] *= -1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.ctx.strokeStyle != this.rndr.c && this.mixedColors)\n\t\t\t\t\t\tthis.ctx.strokeStyle = this.rndr.c;\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.mixedColors) this.ctx.stroke();\n\t\t\t}\n\t\t}\n\t\tif (!this.mixedColors) this.ctx.stroke();\n\t\tif (this.onDraw) this.onDraw();\n\t}\n\n\tload(src, callback) {\n\t\tfetch(src)\n\t\t\t.then(response => { return response.json() })\n\t\t\t.then(data => {\n\t\t\t\tthis.loadData(data, callback);\n\t\t\t})\n\t\t\t.catch(error => { console.error(error) });\n\t}\n\n\tloadJSON(json, callback) {\n\t\tthis.loadData(json, callback);\n\t}\n\n\tloadData(json, callback) {\n\t\tthis.loaded = true;\n\t\t// console.time('load drawings');\n\t\t// console.log(json.d.length);\n\t\t// console.log(json);\n\t\tfor (let i = 0; i < json.d.length; i++) {\n\t\t\tconst drawing = json.d[i];\n\t\t\tlet d;\n\t\t\tif (drawing) {\n\t\t\t\td = [];\n\t\t\t\tfor (let j = 0; j < drawing.length; j++) {\n\t\t\t\t\tconst point = drawing[j];\n\t\t\t\t\tif (point) d.push({ x: point[0], y: point[1] });\n\t\t\t\t\telse d.push('end');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\td = null;\n\t\t\t}\n\t\t\tthis.drawings[i] = d;\n\t\t}\n\t\t// console.timeEnd('load drawings');\n\n\t\tthis.layers = json.l;\n\n\t\tfor (const key in json.s) {\n\t\t\tthis.states[key] = json.s[key];\n\t\t}\n\t\tif (this.states.default)\n\t\t\tthis.states.default.end = this.endFrame;\n\n\t\tthis.intervalRatio = this.lineInterval / (1000 / json.fps);\n\n\t\tif (json.mc) this.mixedColors = json.mc; /* hmm .. over ride? */\n\n\t\t// this.isPlaying = true; /* off for animate ? */\n\n\t\t/* need width and height for infinite hell ?? */\n\t\tthis.width = json.w;\n\t\tthis.height = json.h;\n\n\t\tif (callback) callback(json);\n\t\tif (this.onLoad) this.onLoad();\n\t}\n\n\tsetOnLoad(callback) {\n\t\tif (this.loaded) callback();\n\t\telse this.onLoad = callback;\n\t}\n}\n\n/* questions \n\t- use A/Anim to make Animation availabe in contexts?\n\t\t- only really in game\n\t\t- maybe Animation and GameAnimation\n\t\t- or Sprite Animation\n\t\t- Anim is not good ... \n\trndr\t\n\t\t- wierd to rndr as only abbreivation?\n\t\t- yes used so often its okay to abbreviate\n\t\t- animate just rests every time ...\n\t\t\t- do i need rndr at all, just layer values and over ride?\n\t\t\t- yeah as is rndr is stupid because it never doesn't reset the values\n\t\t\t\t- what were issues with that?\n\t\t\t\t- 0 undefined at first but there was others ... \n\t\t\t\t- using layers instead of frames makes this better\n\t\t\t\t- maybe keep track of layers chaning?\n\t\t\t\t- that happens with currentFrame between endFrame startFrame\n\t\t\t\t- think more on this\n\t\t\t- otherwise just use const\n\t\t\t\tconst e = over.e !== undefined ? over.e : layer.e;\n\t\t\t- do some performance tests with garden\n\n\n\tanim/game\n\t\t- how to handle width, height ratios for resizing ...\n\t\t- loop is assumed for other anims ...\n\t\t- random frames prob only in game\n\n\tload -- issues \n\t\t- game saves loaded sprites, not necessary for others\n\t\t- game setting sprite size\n\t\t- whole separate loader class?\n\tpre/post draw, needed but should be handled by sub classes?\n\t- onupdate - on draw\n\n\tupdate\n\t\t- comes at the end for game, beginning for anim and animate/play\n\t\t- does update call draw or the other way around ...\n\n\tlayer class ?\n\t\t- more for interface stuff ...\n\t\t- only useful method isInFrame\n\t\t- mm ... start frame, end frame ... \n\t\t- anim one is useful but probab not necessary for game\n\n\trange class\n\t\t- start and end\n\t\t- end can't be smaller than start\n\t\t- what about saving data???  method ... \n\t\t- is this actually usedful? \n*/"]}