{"version":3,"sources":["Drawing.js","LinesAnimation.js","Range.js"],"names":["Drawing","LinesAnimation","[object Object]","ctx","lps","mixedColors","this","loaded","isPlaying","drawings","layers","currentFrame","currentFrameCounter","fps","lineInterval","intervalRatio","rndr","off","x","y","speed","_state","states","default","start","end","over","override","_fps","_lps","frame","n","endFrame","frame4","toFixed","length","Math","max","apply","map","layer","f","e","currentState","state","prop","value","floor","onUpdate","onPlayedState","beginPath","i","len","drawing","d","s","key","t","j","tween","sf","ef","Cool","sv","ev","round","w","random","v","Vector","subtract","divide","moveTo","r","k","p","lineTo","ws","xy","strokeStyle","c","stroke","onDraw","src","callback","fetch","then","response","json","data","loadData","catch","error","console","point","push","l","mc","width","height","h","onLoad","Range"],"mappings":"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","file":"../base.min.js","sourcesContent":["class Drawing {\n\t\n}","class LinesAnimation {\n\tconstructor(ctx, lps, mixedColors) {\n\t\tthis.ctx = ctx;\n\t\tthis.loaded = false;\n\t\tthis.isPlaying = false;\n\t\tthis.drawings = [];\n\t\tthis.layers = [];\n\t\tthis.currentFrame = 0;\n\t\tthis.currentFrameCounter = 0; // floats\n\t\t\n\t\tthis.lps = lps || 12;\n\t\tthis.fps = lps || 12;\n\t\tthis.lineInterval = 1000 / this.lps;\n\t\tthis.intervalRatio = 1;\n\n\t\tthis.mixedColors = mixedColors || true;\n\t\t\n\t\tthis.rndr = {\n\t\t\toff: { x: 0, y: 0 },\n\t\t\tspeed: { x: 0, y: 0 }\n\t\t};\n\n\t\tthis._state = 'default';\n\t\tthis.states = { 'default': {start: 0, end: 0 } };\n\n\t\tthis.over = {};\n\t\tthis.override = true;\n\t}\n\n\tset fps(fps) {\n\t\tthis._fps = +fps;\n\t\tthis.intervalRatio = this.lineInterval / (1000 / +fps);\n\t}\n\n\tget fps() {\n\t\treturn this._fps;\n\t}\n\n\tset lps(lps) {\n\t\tthis._lps = +lps;\n\t\tthis.lineInterval = 1000 / +lps;\n\t\tthis.intervalRatio = this.lineInterval / (1000 / this.fps);\n\t}\n\n\tget lps() {\n\t\treturn this._lps;\n\t}\n\n\tset frame(n) {\n\t\tthis.currentFrame = this.currentFrameCounter = +n;\n\t\tif (this.states.default) {\n\t\t\tif (this.states.default.end != this.endFrame)\n\t\t\t\tthis.states.default.end = this.endFrame;\n\t\t}\n\t}\n\n\tget frame4() {\n\t\treturn +this.currentFrameCounter.toFixed(4);\n\t}\n\n\tget endFrame() {\n\t\treturn this.layers.length > 0 ?\n\t\t\tMath.max.apply(Math, this.layers.map(layer => { return layer.f.e; }))\n\t\t\t: 0;\n\t}\n\n\tget currentState() {\n\t\treturn this.states[this.state];\n\t}\n\n\tset state(state) {\n\t\tif (this._state != state && this.states[state]) {\n\t\t\tthis._state = state;\n\t\t\tif (this.currentState) this.frame = this.currentState.start;\n\t\t\t\n\t\t\t/* bad temp fix ... for what? \n\t\t\tif (!this.isPlaying && state != 'default') \n\t\t\t\tthis.isPlaying = true; \n\t\t\ttake it out until i remember\n\t\t\t*/\n\t\t}\n\t}\n\n\tget state() {\n\t\treturn this._state;\n\t}\n\n\toverrideProperty(prop, value) {\n\t\tthis.over[prop] = value;\n\t\tthis.override = true;\n\t}\n\n\tcancelOverride() {\n\t\tthis.over = {}\n\t\tthis.override = false;\n\t}\n\n\tupdate() {\n\t\tif (this.isPlaying) {\n\t\t\tif (this.currentFrame <= this.currentState.end) {\n\t\t\t\tthis.currentFrameCounter += this.intervalRatio;\n\t\t\t\tthis.currentFrame = Math.floor(this.currentFrameCounter);\n\t\t\t\tif (this.onUpdate) this.onUpdate();\n\t\t\t}\n\t\t\t// console.log(this.frame4, this.currentState.end, this.currentState.end + 1 - this.intervalRatio, this.frame4 > this.currentState.end + 1 - this.intervalRatio);\n\t\t\t// console.log(this.frame4, this.currentState.end + 1);\n\t\t\t/* fuck me */\n\t\t\tif (this.frame4 >= this.currentState.end + 1) {\n\t\t\t\tthis.frame = this.currentState.start;\n\t\t\t\t/* loop ? */\n\t\t\t\tif (this.onPlayedState) this.onPlayedState();\n\t\t\t}\n\t\t\tif (this.onUpdate) this.onUpdate();\n\t\t}\n\t}\n\n\tdraw(x, y) {\n\t\t// if (this.debug) console.log(x, y);\n\t\tif (!this.mixedColors) this.ctx.beginPath();\n\t\tfor (let i = 0, len = this.layers.length; i < len; i++) {\n\t\t\tconst layer = this.layers[i];\n\t\t\tconst drawing = this.drawings[layer.d];\n\t\t\tif (this.currentFrame >= layer.f.s && this.currentFrame <= layer.f.e) {\n\t\t\t\tthis.rndr.s = 0;\n\t\t\t\tthis.rndr.e = drawing.length;\n\n\t\t\t\tfor (const key in layer) {\n\t\t\t\t\tthis.rndr[key] = layer[key];\n\t\t\t\t}\n\n\t\t\t\tif (x) this.rndr.x += x;\n\t\t\t\tif (y) this.rndr.y += y;\n\n\t\t\t\tif (layer.t) {\n\t\t\t\t\tfor (let j = 0; j < layer.t.length; j++) {\n\t\t\t\t\t\tconst tween = layer.t[j];\n\t\t\t\t\t\tif (tween.sf <= this.currentFrame && tween.ef >= this.currentFrame) {\n\t\t\t\t\t\t\tthis.rndr[tween.prop] = Cool.map(this.currentFrame, tween.sf, tween.ef, tween.sv, tween.ev);\n\t\t\t\t\t\t\tif (tween.prop == 's' || tween.prop == 'e')\n\t\t\t\t\t\t\t\tthis.rndr[tween.prop] = Math.round(this.rndr[tween.prop]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.override) {\n\t\t\t\t\tfor (const key in this.over) {\n\t\t\t\t\t\tthis.rndr[key] = this.over[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.rndr.w > 0) {\n\t\t\t\t\tthis.rndr.off.x = Cool.random(0, this.rndr.w); // random start of wiggle offset\n\t\t\t\t\tthis.rndr.off.y = Cool.random(0, this.rndr.w);\n\t\t\t\t\tthis.rndr.speed.x = Cool.random(-this.rndr.v, this.rndr.v);\n\t\t\t\t\tthis.rndr.speed.y = Cool.random(-this.rndr.v, this.rndr.v);\n\t\t\t\t} else {\n\t\t\t\t\tthis.rndr.off.x = 0;\n\t\t\t\t\tthis.rndr.off.y = 0;\n\t\t\t\t\tthis.rndr.speed.x = 0;\n\t\t\t\t\tthis.rndr.speed.y = 0;\n\t\t\t\t}\n\n\t\t\t\tif (this.mixedColors) this.ctx.beginPath();\n\t\t\t\tfor (let j = this.rndr.s; j < this.rndr.e - 1; j++) {\n\t\t\t\t\tconst s = drawing[j];\n\t\t\t\t\tconst e = drawing[j + 1];\n\t\t\t\t\tconst v = new Cool.Vector(e.x, e.y);\n\t\t\t\t\tv.subtract(s);\n\t\t\t\t\tv.divide(this.rndr.n);\n\t\t\t\t\tthis.ctx.moveTo(\n\t\t\t\t\t\tthis.rndr.x + s.x + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.x, \n\t\t\t\t\t\tthis.rndr.y + s.y + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.y\n\t\t\t\t\t);\n\t\t\t\t\tfor (let k = 0; k < this.rndr.n; k++) {\n\t\t\t\t\t\tconst p = new Cool.Vector(s.x + v.x * k, s.y + v.y * k);\n\t\t\t\t\t\tthis.ctx.lineTo( \n\t\t\t\t\t\t\tthis.rndr.x + p.x + v.x + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.x,\n\t\t\t\t\t\t\tthis.rndr.y + p.y + v.y + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.y\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (k == 0 || this.rndr.ws) {\n\t\t\t\t\t\t\tif (this.rndr.w > 0) {\n\t\t\t\t\t\t\t\tfor (const xy in this.rndr.off) {\n\t\t\t\t\t\t\t\t\tthis.rndr.off[xy] += this.rndr.speed[xy];\n\t\t\t\t\t\t\t\t\tif (this.rndr.off[xy] >= this.rndr.w || \n\t\t\t\t\t\t\t\t\t\tthis.rndr.off[xy] <= -this.rndr.w) {\n\t\t\t\t\t\t\t\t\t\tthis.rndr.speed[xy] *= -1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.ctx.strokeStyle != this.rndr.c && this.mixedColors)\n\t\t\t\t\t\tthis.ctx.strokeStyle = this.rndr.c;\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.mixedColors) this.ctx.stroke();\n\t\t\t}\n\t\t}\n\t\tif (!this.mixedColors) this.ctx.stroke();\n\t\tif (this.onDraw) this.onDraw();\n\t}\n\n\tload(src, callback) {\n\t\tfetch(src)\n\t\t\t.then(response => { return response.json() })\n\t\t\t.then(data => {\n\t\t\t\tthis.loadData(data, callback);\n\t\t\t})\n\t\t\t.catch(error => { console.error(error) });\n\t}\n\n\tloadJSON(json, callback) {\n\t\tthis.loadData(json, callback);\n\t}\n\n\tloadData(json, callback) {\n\t\tthis.loaded = true;\n\t\t// console.time('load drawings');\n\t\t// console.log(json.d.length);\n\t\t// console.log(json);\n\t\tfor (let i = 0; i < json.d.length; i++) {\n\t\t\tconst drawing = json.d[i];\n\t\t\tlet d;\n\t\t\tif (drawing) {\n\t\t\t\td = [];\n\t\t\t\tfor (let j = 0; j < drawing.length; j++) {\n\t\t\t\t\tconst point = drawing[j];\n\t\t\t\t\tif (point) d.push({ x: point[0], y: point[1] });\n\t\t\t\t\telse d.push('end');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\td = null;\n\t\t\t}\n\t\t\tthis.drawings[i] = d;\n\t\t}\n\t\t// console.timeEnd('load drawings');\n\n\t\tthis.layers = json.l;\n\n\t\tfor (const key in json.s) {\n\t\t\tthis.states[key] = json.s[key];\n\t\t}\n\t\tif (this.states.default)\n\t\t\tthis.states.default.end = this.endFrame;\n\n\t\tthis.intervalRatio = this.lineInterval / (1000 / json.fps);\n\n\t\tif (json.mc) this.mixedColors = json.mc; /* hmm .. over ride? */\n\n\t\t// this.isPlaying = true; /* off for animate ? */\n\n\t\t/* need width and height for infinite hell ?? */\n\t\tthis.width = json.w;\n\t\tthis.height = json.h;\n\n\t\tif (callback) callback(json);\n\t\tif (this.onLoad) this.onLoad();\n\t}\n\n\tsetOnLoad(callback) {\n\t\tif (this.loaded) callback();\n\t\telse this.onLoad = callback;\n\t}\n}\n\n/* questions \n\t- use A/Anim to make Animation availabe in contexts?\n\t\t- only really in game\n\t\t- maybe Animation and GameAnimation\n\t\t- or Sprite Animation\n\t\t- Anim is not good ... \n\trndr\t\n\t\t- wierd to rndr as only abbreivation?\n\t\t- yes used so often its okay to abbreviate\n\t\t- animate just rests every time ...\n\t\t\t- do i need rndr at all, just layer values and over ride?\n\t\t\t- yeah as is rndr is stupid because it never doesn't reset the values\n\t\t\t\t- what were issues with that?\n\t\t\t\t- 0 undefined at first but there was others ... \n\t\t\t\t- using layers instead of frames makes this better\n\t\t\t\t- maybe keep track of layers chaning?\n\t\t\t\t- that happens with currentFrame between endFrame startFrame\n\t\t\t\t- think more on this\n\t\t\t- otherwise just use const\n\t\t\t\tconst e = over.e !== undefined ? over.e : layer.e;\n\t\t\t- do some performance tests with garden\n\n\n\tanim/game\n\t\t- how to handle width, height ratios for resizing ...\n\t\t- loop is assumed for other anims ...\n\t\t- random frames prob only in game\n\n\tload -- issues \n\t\t- game saves loaded sprites, not necessary for others\n\t\t- game setting sprite size\n\t\t- whole separate loader class?\n\tpre/post draw, needed but should be handled by sub classes?\n\t- onupdate - on draw\n\n\tupdate\n\t\t- comes at the end for game, beginning for anim and animate/play\n\t\t- does update call draw or the other way around ...\n\n\tlayer class ?\n\t\t- more for interface stuff ...\n\t\t- only useful method isInFrame\n\t\t- mm ... start frame, end frame ... \n\t\t- anim one is useful but probab not necessary for game\n\n\trange class\n\t\t- start and end\n\t\t- end can't be smaller than start\n\t\t- what about saving data???  method ... \n\t\t- is this actually usedful? \n*/","class Range {\n\t\n}"]}